#!/bin/bash
#	Filename:-		gpdbrestore
#	Status:-		Released
#	Author:-		G Coombe
#	Contact:-		gcoombe@greenplum.com
#	Release date:-		May 2007
#	Release stat:-		Greenplum Co internal
#                               Copyright (c) Metapa 2005. All Rights Reserved.
#                               Copyright (c) Greenplum 2005. All Rights Reserved
#	Brief descn:-		Restores a Greenplum database from a set of
#				database dump files created vi gpcrondump
#******************************************************************************
# Update History
#******************************************************************************
# Ver	Date		Who		Update
#******************************************************************************
# Detailed Description
#******************************************************************************
#
#******************************************************************************
# Prep Code
# Source required functions file, this required for script to run
# exit if cannot locate this file. Change location of FUNCTIONS variable
# as required.
WORKDIR=`dirname $0`
FUNCTIONS=$WORKDIR/lib/gp_bash_functions.sh
if [ -f $FUNCTIONS ]; then
		. $FUNCTIONS
else
		echo "[FATAL:]-Cannot source $FUNCTIONS file Script Exits!"
		exit 2
fi
#******************************************************************************
# Location Variables
#******************************************************************************

#******************************************************************************
# Command Variables
#******************************************************************************

#******************************************************************************
# Script Specific Variables
#******************************************************************************
INTERACTIVE=1
VERBOSE=1
unset NOANALYZE
TIME=`$DATE +%H":"%M":"%S`
CUR_DATE=`$DATE +%Y%m%d`
PROG_NAME=`$BASENAME $0`
HELP_DOC_NAME=`$ECHO $PROG_NAME|$AWK -F'.' '{print $1}'`_help
QD_NAME=`hostname`
EXIT_STATUS=0
TS_LEN=14 		#Expected length of timestamp key
CREATEDB_PREFIX="gp_cdatabase_1_1_"
DBDUMP_PREFIX="gp_dump_"
GLOBAL_OBJECT_PREFIX="gp_global_1_1_"
MASTER_DBDUMP_PREFIX="gp_dump_1_1"
DROP_DB=0
RESTORE_GLOBAL=0
DUMP_DIR=db_dumps
GPSEGDBRESTORE=$WORKDIR/lib/gpsegdbrestore.sh
PARALLEL_STATUS_FILE=/tmp/${PROG_NAME}_parallel_status_file.$$
WAIT_LIMIT=14400
#******************************************************************************
# Functions
#******************************************************************************
#
USAGE () {
	if [ -f ${GPDOCDIR}/$HELP_DOC_NAME ] && [ x"" == x"$SCRIPT_USAGE" ];then
		$LESSCMD ${GPDOCDIR}/$HELP_DOC_NAME
		exit 0
	else
		$ECHO	
		$ECHO "      `basename $0`"
		$ECHO
		$ECHO "      Restores a Greenplum database or a table from a set of database backup files"
		$ECHO "      which were generated by gpcrondump"
		$ECHO
		$ECHO "      Usage:"
		$ECHO "      $0 [OPTIONS]"
		$ECHO
		$ECHO "      General options:"
		$ECHO "      -?, display this help message & exit" 
		$ECHO "      -v, display version information & exit"
		$ECHO
		$ECHO "      Logging options:"
		$ECHO "      -q, quiet mode, do not log progress to screen [default:- verbose output to screen]"
		$ECHO "      -l, <logfile directory> alternative logfile directory [optional]"
		$ECHO "      -a, don't ask to confirm generation process [default:- ask]"
		$ECHO "      -D, set log output to debug level, shows all function calls"
		$ECHO
		$ECHO "      Connection options:"
		$ECHO "      -d, <Master instance directory> name of alternative Master instance to run against [optional]"
		$ECHO
		$ECHO "      Database restore options:"
		$ECHO "      -t, <timestamp> timestamp key of backup file set that should be used for restore"
		$ECHO "          Mandatory if -b and -R options not supplied"
		$ECHO "          Expects dump file set to be on the Greenplum Array"
		$ECHO "      -b, <YYYYMMDD> ${DUMP_DIR}/<YYYYMMDD> directory where dump files located on the GP Array"
		$ECHO "          Mandatory if -t and -R options not supplied"
		$ECHO "          Expects dump file set to be on the Greenplum Array"
		$ECHO "      -R, <hostname:dir_path> hostname and full directory path where backup set located"
		$ECHO "          Utility will recover files to Master and segment hosts and then start restore"
		$ECHO "          process"	
		$ECHO "          Mandatory if -t and -b options not supplied"
		$ECHO "      -s, <database name> search for latest backup set for the named database"
		$ECHO "          Overrides -t -b and -R  options"
		$ECHO "          Expects dump file set to be on the Greenplum Array"
		$ECHO "      -G, restore global objects dump file if found in dump set to be restored,"
		$ECHO "          the global objects file is secured via gpcrondump -G option, and has file name"
		$ECHO "          format ${GLOBAL_OBJECT_PREFIX}<timestamp>" 
		$ECHO "      -e, Drop (erase) restore database before recovery commences"
		$ECHO "      -T, <schema.tablename> restore a single table from a backup set, for multiple tables"
		$ECHO "          supply a comma separated list of schema.tablenames. Note, table must exist in target"
		$ECHO "          database"
		$ECHO "      -L, list table names in dump file, can only be used with -t <timestamp> option"
		$ECHO "          Will display all tables in dump file and then exit"
		$ECHO "      -B, <number> run this batch of table restore create dump file processes in parallel"
		$ECHO "          [default $BATCH_DEFAULT]"
		$ECHO "      --noanalyze, suppress the ANALYZE run following a successful restore.  The user is"
		$ECHO "          responsible for running ANALYZE on any restored tables; failure to run ANALYZE"
		$ECHO "          following a restore may result in poor database performance."
		$ECHO
		$ECHO "      Return codes:"
		$ECHO "      0 No problems encountered with requested operation"
		$ECHO "      1 Warning generated, but restore completed"
		$ECHO "      2 Fatal error, unable to complete restore request"
		$ECHO
		exit $EXIT_STATUS
	fi
}

UNKNOWN_OPTION () {
		$ECHO
		$ECHO "[ERROR]:-Unknown option $1"
		USAGE
}

PROMPT_CONTINUE () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
		SUFFIX_COUNT=${#SUFFIX_ARRAY[@]}
		LOG_MSG "[INFO]:------------------------------------------" 1
		LOG_MSG "[INFO]:-Greenplum database restore parameters" 1
		LOG_MSG "[INFO]:------------------------------------------" 1
		if [ x"" == x"$RESTORE_TABLE" ];then
			LOG_MSG "[INFO]:-Restore type               = Full Database" 1
			LOG_MSG "[INFO]:-Database to be restored    = $RESTORE_DBNAME" 1
			if [ $DROP_DB -eq 1 ];then
			LOG_MSG "[INFO]:-Drop and re-create db      = On" 1
			else
			LOG_MSG "[INFO]:-Drop and re-create db      = Off" 1
			fi
		else
			LOG_MSG "[INFO]:-Restore type               = Table Restore" 1
			LOG_MSG "[INFO]:-Database name              = $RESTORE_DBNAME" 1
			LOG_MSG "[INFO]:------------------------------------------" 1
			LOG_MSG "[INFO]:-Table restore list" 1
			LOG_MSG "[INFO]:------------------------------------------" 1
			for I in "${RESTORE_LIST[@]}"
			do
			LOG_MSG "[INFO]:-Table                      = $I" 1
			done
			LOG_MSG "[INFO]:------------------------------------------" 1
			if [ "${#TAB_COUNT_ARRAY[@]}" -ne 0 ];then
			LOG_MSG "[INFO]:------------------------------------------" 1
			LOG_MSG "[WARN]:-Following tables have non-zero row counts $WARN_MARK" 1
			LOG_MSG "[INFO]:------------------------------------------" 1
			for I in "${TAB_COUNT_ARRAY[@]}"
			do
			LOG_MSG "[WARN]:-Table:Row count            = $I" 1
			done
			LOG_MSG "[INFO]:------------------------------------------" 1
			fi
		fi
		if [ x"" != x"$DB_TIMESTAMP" ] && [ x"" == x"$RESTORE_TABLE" ];then
		LOG_MSG "[INFO]:-Restore method             = Restore specific timestamp" 1
		fi
		if [ x"" != "$SEARCH_FOR_LATEST_DUMP_SET" ] && [ x"" == x"$RESTORE_TABLE" ];then
		LOG_MSG "[INFO]:-Restore method             = Search for latest" 1
		fi
		if [ x"" != x"$DB_DATE_DIR" ] && [ x"" == x"$RESTORE_TABLE" ];then
		LOG_MSG "[INFO]:-Restore method             = Restore specific date" 1
		fi
		if [ x"" != x"$RESTORE_TABLE" ];then
		LOG_MSG "[INFO]:-Restore method             = Specific table restore" 1
		fi
		if [ x"" != x"$DB_FILE_HOST" ];then
		LOG_MSG "[INFO]:-Restore method             = Remote host" 1
		LOG_MSG "[INFO]:-Recovery hostname          = $DB_HOST" 1
		LOG_MSG "[INFO]:-Remote recovery path       = $DB_HOST_PATH" 1
		fi
		LOG_MSG "[INFO]:-Restore timestamp          = $RESTORE_TIMESTAMP" 1
		if [ x"" != x"$COMPRESS" ];then
		LOG_MSG "[INFO]:-Restore compressed dump    = On" 1
		else
		LOG_MSG "[INFO]:-Restore compressed dump    = Off" 1
		fi
		LOG_MSG "[INFO]:-DBID List for restore      = $DBID_LIST" 1
		LOG_MSG "[INFO]:-Content list for restore   = $CONTENT_LIST" 1
		LOG_MSG "[INFO]:-Restore type               = $RESTORE_TYPE" 1
		if [ $RESTORE_GLOBAL -eq 1 ];then
		LOG_MSG "[INFO]:-Restore global objects     = On" 1
		else
		LOG_MSG "[INFO]:-Restore global objects     = Off" 1
		fi
		LOG_MSG "[INFO]:-Array fault tolerance      = $FAIL_TYPE" 1
		$ECHO
		GET_REPLY "Continue with database restore process"
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}	

PRE_RESTORE_CHECKS () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	GET_MASTER_PORT $MASTER_DATA_DIRECTORY
	#Get fault action setting
	FAULT_ACTION=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"show gp_fault_action;"`
	ERROR_CHK $? "obtain array fault action value" 2
	#Check for any failures
	FAIL_COUNT=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select count(*) from $GP_PG_VIEW as _gp_pg_view where content<>-1 and isprimary='t' and valid='f';"`
	ERROR_CHK $? "obtain invalid primary segment count" 2
	if [ $FAULT_ACTION == "readonly" ] && [ $FAIL_COUNT -ne 0 ];then
		LOG_MSG "[FATAL]:-There are $FAIL_COUNT primary segment databases marked as invalid" 1
		LOG_MSG "[FATAL]:-Array fault action is set to readonly, unable to initiate a restore" 1
		LOG_MSG "[INFO]:-Use $GPRECOVERSEG utility to recover failed segment instances database" 1
		ERROR_EXIT "[FATAL]:-Unable to continue" 2
	fi
	TOTAL_PRIMARY_SEGMENTS=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select count(*) from $CONFIG_TABLE as _gp_config where content<>-1 and preferred_role='p';"`
	ERROR_CHK $? "obtain number of primary segments" 2
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

CHK_PARAM () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	if [ x"" == x"$DB_TIMESTAMP" ] && [ x"" != x"$LIST_TABLES" ];then
		ERROR_EXIT "[FATAL]:-Need to supply -t <timestamp> for -L option" 2
	fi
	if [ x"" != x"$DB_TIMESTAMP" ] && [ x"" != x"$DB_DATE_DIR" ];then
		ERROR_EXIT "[FATAL]:-Cannot supply both -t and -b options" 2
	fi
	if [ x"" != x"$DB_TIMESTAMP" ] && [ x"" != x"$DB_FILE_HOST" ];then
		ERROR_EXIT "[FATAL]:-Cannot supply both -t and -R options" 2
	fi
	if [ x"" != x"$SEARCH_FOR_DBNAME" ] && [ x"" != x"$DB_FILE_HOST" ];then
		ERROR_EXIT "[FATAL]:-Cannot supply both -s and -R options" 2
	fi
	if [ x"" != x"$DB_FILE_HOST" ] && [ x"" != x"$DB_DATE_DIR" ];then
		ERROR_EXIT "[FATAL]:-Cannot supply both -R and -b options" 2
	fi	
	#See if neither -t , -R or -b have been supplied
	if [ x"" == x"$DB_TIMESTAMP" ] && [ x"" == x"$DB_DATE_DIR" ] && [ x"" == x"$DB_FILE_HOST" ] && [ x"" == x"$SEARCH_FOR_DBNAME" ];then
		ERROR_EXIT "[FATAL]:-Must supply at least one of either -t, -b, -R or -s options or valid combination" 2
	fi
	if [ x"" != x"$SEARCH_FOR_DBNAME" ];then
		#Make additional checks on the database name passed
		FIRST_CHAR=`$ECHO $SEARCH_FOR_DBNAME|$CUT -c1`
		if [ `$ECHO $FIRST_CHAR|$GREP -c "-"` -eq 1 ];then
			ERROR_EXIT "[FATAL]:-Invalid database name supplied" 2
		fi
	fi	
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

VALIDATE_PARAMS () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#Check timestamp if supplied
	if [ x"" != x"$DB_TIMESTAMP" ];then
		if [ `$ECHO $DB_TIMESTAMP|$TR -d '\n'|$WC -c` -ne $TS_LEN ];then
			ERROR_EXIT "[FATAL]:-Invalid -t<timestamp> value, expected $TS_LEN digits" 2
		fi
		I=1
		while [ $I -le $TS_LEN ]
		do
			if [ `$ECHO $DB_TIMESTAMP|$TR -d '\n'|$CUT -b$I|$GREP -c "[0-9]"` -ne 1 ];then
			 	ERROR_EXIT "[FATAL]:-Invalid -t<timestamp> value, contains a none numeric value" 2
			fi
			((I=$I+1))
		done
	fi
	#Check if database directory date supplied
	if [ x"" != x"$DB_DATE_DIR" ];then
		if [ `$ECHO $DB_DATE_DIR|$TR -d '\n'|$WC -c` -ne 8 ];then
			ERROR_EXIT "[FATAL]:-Invalid -b<YYYYMMDD> value, expected 6 numbers" 2
		fi
		I=1
		while [ $I -le 8 ]
		do
			if [ `$ECHO $DB_DATE_DIR|$TR -d '\n'|$CUT -b$I|$GREP -c "[0-9]"` -ne 1 ];then
				ERROR_EXIT "[FATAL]:-Invalid -b<YYYYMMDD> value, contains a none numeric character" 2
			fi
			((I=$I+1))
		done
		#Now check validity of date
		DB_YEAR=`$ECHO $DB_DATE_DIR|$CUT -b1-4`
		DB_MONTH=`$ECHO $DB_DATE_DIR|$CUT -b5-6`
		DB_DAY=`$ECHO $DB_DATE_DIR|$CUT -b7-8`
		MONTH_CHECK="01 02 03 04 05 06 07 08 09 10 11 12"
		DAY_CHECK="$MONTH_CHECK 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"
		#Check the year
		if [ $DB_YEAR -lt 2000 ];then
			ERROR_EXIT "[FATAL]:-Invalid date supplied $DB_YEAR with -b option, must be greater than 2000" 2
		else
			if [ $DB_YEAR -gt `$DATE +%Y` ];then
				ERROR_EXIT "[FATAL]:-Future date supplied $DB_YEAR with -b option, must be `$DATE +%Y` or earlier" 2
			fi
		fi
		#Check the month
		if [ `$ECHO $MONTH_CHECK|$GREP -c "$DB_MONTH"` -ne 1 ];then
			ERROR_EXIT "[FATAL]:-Invalid month supplied $DB_MONTH with -b option" 2
		fi	
		if [ `$ECHO $DAY_CHECK|$GREP -c "$DB_DAY"` -ne 1 ];then
			ERROR_EXIT "[FATAL]:-Invalid day supplied $DB_DAY with -b option" 2
		fi
	fi
	#Check if hostname:dir_path supplied
	if [ x"" != x"$DB_FILE_HOST" ];then
		if [ `$ECHO $DB_FILE_HOST|$AWK -F":" '{print NF}'` -ne 2 ];then
			ERROR_EXIT "[FATAL]:-Invalid -R<hostname:dir_path> value, expected two values : separated" 2
		fi
		DB_HOST=`$ECHO $DB_FILE_HOST|$AWK -F":" '{print $1}'`
		DB_HOST_PATH=`$ECHO $DB_FILE_HOST|$AWK -F":" '{print $2}'`
		if [ `$ECHO $DB_HOST_PATH|$GREP -c "/"` -eq 0 ];then
			 ERROR_EXIT "[FATAL]:-Invalid -R<hostname:dir_path> full path incorrect" 2
		fi
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

GET_DUMP_TABLES () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	
	VALIDATE_TIMESTAMP

	# The awk stage below scans a dump file for the "SET search_path" statements to obtain
	# the properly quoted schema name, the "COPY" statements to obtain the properly quoted
	# table name, and the "Data for Name" comment line to obtain the owner id.  The 
	# dump_tables local variable contains a newline-separated list of entries identifying 
	# each table appearing in the dump.  Each entry is of the form "schema.table\towner".
	local dump_tables cat gz
	if [ "$COMPRESS" ];then
		cat="$ZCAT"
		gz=".gz"
	else
		cat="$CAT"
		gz=
	fi
	dump_tables=$(${cat} ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$RESTORE_DIR_DATE/${MASTER_DBDUMP_PREFIX}_${RESTORE_TIMESTAMP}${gz}| \
		$AWK '
			BEGIN {
				schema=""
				owner=""
			}
			/^SET search_path = / {
				# Strip schema identifier from "SET search_path = <schema>, pg_catalog;"
				schema = substr($0, 19)
				schema = substr(schema, 1, index(schema, ", pg_catalog;") - 1)
			}
			/^-- Data for Name: / {
				# Strip owner identifier from "-- Data for Name: ... ; Owner: <owner> "
				owner = substr($0, index($0, "; Owner: ") + 9) 
				if ( owner ~ /[ \t]+$/ ) {
					for ( i = length(owner); i > 0; i-- ) {
						if (substr(owner, i, 1) !~ /[ \t]/)
							break
					}
					owner = substr(owner, 1, i)
				}
			}
			/^COPY / {
				# Strip table identifier from "COPY <table> [(<column_list>)] FROM stdin;"
				table = substr($0, 6)
				if ( table ~ /\) FROM stdin;/) {
					# COPY statement has a column list
					if ( substr(table, 1, 1) == "\"" ) {
						table = substr(table, 1, index(table, "\" ("))
					} else {
						table = substr(table, 1, index(table, " (") - 1)
					}
				} else {
					# COPY statement has no column list
					table = substr(table, 1, index(table, " FROM stdin;") - 1)
				}
				if ( table ~ /[ \t]+$/ ) {
					for ( i = length(table); i > 0; i-- ) {
						if (substr(table, i, 1) !~ /[ \t]/)
							break
					}
					table = substr(table, 1, i)
				}
				print schema "." table "\t" owner "\n"
			}')
	
	# Assign the list of tables/owners appearing in the dump to DUMP_TABLE_ARRAY using only 
	# a newline as a separator.
	local old_IFS="$IFS"
	IFS=$'\n'
	DUMP_TABLE_ARRAY=(${dump_tables})
	IFS="$old_IFS"
	
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

LIST_DUMP_TABLES () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	
	LOG_MSG "[INFO]:---------------------------------------------------------------------" 1
	LOG_MSG "[INFO]:-List of database tables for dump file with time stamp $RESTORE_TIMESTAMP" 1
	LOG_MSG "[INFO]:---------------------------------------------------------------------" 1
	GET_DUMP_TABLES
	for DUMP_ITEM in "${DUMP_TABLE_ARRAY[@]}"
	do
		TAB=`$ECHO "$DUMP_ITEM"|$AWK -F"\t" '{print $1}'`
		OWNER=`$ECHO "$DUMP_ITEM"|$AWK -F"\t" '{print $2}'`	
		LOG_MSG "[INFO]:-Table $TAB Owner $OWNER" 1
	done
	LOG_MSG "[INFO]:---------------------------------------------------------------------" 1
	exit 0
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

VALIDATE_TIMESTAMP () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#See if we can find at least one file that contains this timestamp value on the Master host
	if [ `$FIND ${MASTER_DATA_DIRECTORY}/${DUMP_DIR} -name "*$DB_TIMESTAMP"|$WC -l` -eq 0 ];then
		LOG_MSG "[FATAL]:-Unable to locate any files in ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}" 1
		ERROR_EXIT "[FATAL]:-with timestamp=$DB_TIMESTAMP" 2
	else
		#Get directory prefix
		RESTORE_DIR=`$DIRNAME \`$FIND ${MASTER_DATA_DIRECTORY}/${DUMP_DIR} -name "*$DB_TIMESTAMP"|$HEAD -1\``
		RESTORE_DIR_DATE=`$BASENAME $RESTORE_DIR`
		GP_RESTORE_DIR=${DUMP_DIR}/$RESTORE_DIR_DATE
		RESTORE_TIMESTAMP=$DB_TIMESTAMP
		COMPRESS=`ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$RESTORE_DIR_DATE/${MASTER_DBDUMP_PREFIX}_${RESTORE_TIMESTAMP}*|$AWK -F"." '{print $2}'`
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

SELECT_MULTI_FILE () {
	OPTION=0
	SPC="        "
	LOG_MSG "[INFO]:-Select required dump file timestamp to restore" 1
	$ECHO "${SPC} #           Date    Time"
	$ECHO "${SPC}--------------------------"
	for DUMP_LINE in ${DUMP_LIST_ARRAY[@]}
	do
		DUMP_DATE=`$ECHO $DUMP_LINE|$CUT -c1-8`
		DUMP_TIME=`$ECHO $DUMP_LINE|$CUT -c9-14`
		$ECHO "${SPC}[$OPTION] ...... $DUMP_DATE $DUMP_TIME"
		((OPTION=$OPTION+1))
	done
	$ECHO "${SPC}Enter timestamp number to restore >"
	read REPLY
	if [ x"" == x"$REPLY" ];then
		ERROR_EXIT "[WARN]:-Invalid or null input" 2
	fi
	if [ `$ECHO $REPLY|$EGREP -c "[a-z]|[A-Z]|_\-"` -ne 0 ];then
		ERROR_EXIT "[WARN]:-Invalid or null input" 2
	fi
	#if [ `$ECHO "0 1 2 3 4 5 6 7 8 9"|$GREP -c $REPLY` -eq 0 ];then
	if [ `$ECHO $REPLY|$EGREP -c "0|1|2|3|4|5|6|7|8|9"` -eq 0 ];then
		ERROR_EXIT "[WARN]:-Invalid or null input" 2
	fi
	if [ $REPLY -lt 0 ] || [ $REPLY -gt $OPTION ];then
		ERROR_EXIT "[WARN]:-Invalid or null input" 2
	fi
	RESTORE_TIMESTAMP=${DUMP_LIST_ARRAY[$REPLY]}
	RESTORE_DIR_DATE=`$ECHO ${DUMP_LIST_ARRAY[$REPLY]}|$CUT -c1-8`
}

VALIDATE_DB_DATE_DIR () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	MULTI_FILE=0
	if [ ! -d ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR ];then
		ERROR_EXIT "[FATAL]:-Directory ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR does not exist" 2
	else
		#Check for a dump file
		if [ `ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR/$MASTER_DBDUMP_PREFIX*|$WC -l` -eq 0 ];then
			ERROR_EXIT "[FATAL]:-Could not locate Master database dump file" 2
		else
			if [ `ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR/$MASTER_DBDUMP_PREFIX*|$WC -l` -gt 1 ];then
				MULTI_FILE=1
				LOG_MSG "[INFO]:-Found multiple backup sets for $DB_DATE_DIR" 1
				DUMP_LIST_ARRAY=(`ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR/$MASTER_DBDUMP_PREFIX*|$TR ' ' '\n'|$AWK -F"/" '{print $NF}'|$AWK -F"_" '{print $NF}'|$CUT -d"." -f1|$TR '\n' ' '`)
				SELECT_MULTI_FILE
			fi
		fi
		RESTORE_DIR=${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR
		GP_RESTORE_DIR=${DUMP_DIR}/$DB_DATE_DIR
		RESTORE_DIR_DATE=$DB_DATE_DIR
		#Now get timestamp for this directory
		if [ $MULTI_FILE -eq 0 ];then
		RESTORE_TIMESTAMP=`$BASENAME  \`ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR/$MASTER_DBDUMP_PREFIX*\`|$AWK -F"." '{print $1}'|$AWK -F"_" '{print $5}'`
		fi
		COMPRESS=`ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR/${MASTER_DBDUMP_PREFIX}_${RESTORE_TIMESTAMP}*|$AWK -F"." '{print $2}'`
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

VALIDATE_DB_FILE_HOST () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#See if host exists
	PING_HOST $DB_HOST
	#See if directory exists on that host
	CHK_DIR $DB_HOST_PATH $DB_HOST
	if [ $EXISTS -ne 0 ];then
		ERROR_EXIT "[FATAL]:-Issue with $DB_HOST_PATH on $DB_HOST" 2
	fi
	#Check for a dump file
	REMOTE_FILE_COUNT=`$TRUSTED_SHELL $DB_HOST "ls $DB_HOST_PATH/$MASTER_DBDUMP_PREFIX*|$WC -l" 2>/dev/null`
	if [ $REMOTE_FILE_COUNT -eq 0 ];then
		ERROR_EXIT "[FATAL]:-Could not locate Master database dump file in $DB_HOST_PATH on $DB_HOST" 2
	else
		if [ $REMOTE_FILE_COUNT -gt 1 ];then
			DUMP_LIST_ARRAY=(`$TRUSTED_SHELL $DB_HOST "ls $DB_HOST_PATH/$MASTER_DBDUMP_PREFIX*"|$TR ' ' '\n'|$AWK -F"/" '{print $NF}'|$AWK -F"_" '{print $NF}'|$CUT -d"." -f1|$TR '\n' ' '`)
			LOG_MSG "[INFO]:-Found multiple backup sets on $DB_HOST" 1
			SELECT_MULTI_FILE
			REMOTE_FILE=`$TRUSTED_SHELL $DB_HOST "ls $DB_HOST_PATH/${MASTER_DBDUMP_PREFIX}_$RESTORE_TIMESTAMP*"`	
		else
			REMOTE_FILE=`$TRUSTED_SHELL $DB_HOST "ls $DB_HOST_PATH/$MASTER_DBDUMP_PREFIX*"`
			RESTORE_TIMESTAMP=`$BASENAME $REMOTE_FILE|$AWK -F'.' '{print $1}'|$AWK -F'_' '{print $5}'`
		fi
	fi
	RESTORE_DIR=$DB_HOST_PATH
	COMPRESS=`$BASENAME $REMOTE_FILE|$AWK -F'.' '{print $2'}`
	REMOTE_DATE=`$ECHO $RESTORE_TIMESTAMP|$CUT -c1-8`
	GP_RESTORE_DIR=${DUMP_DIR}/$REMOTE_DATE
	RESTORE_DIR_DATE=$REMOTE_DATE
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

RECOVER_REMOTE_DUMP_FILES () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	LOG_MSG "[INFO]:-Commencing remote database dump file recovery process, please wait.." 1
	#REM_DATE=`$ECHO $RESTORE_TIMESTAMP|$CUT -b1-8`	
	for REM_LINE in `$ECHO $REMOTE_LIST`
	do
		SEGMENT_HOST=`$ECHO $REM_LINE|$AWK -F":" '{print $1}'`
		SEGMENT_DBID=`$ECHO $REM_LINE|$AWK -F":" '{print $2}'`
		SEGMENT_DIR=`$ECHO $REM_LINE|$AWK -F":" '{print $3}'`
		#SEG_RECOVERY_DIRECTORY=${SEGMENT_DIR}/${DUMP_DIR}/${REM_DATE}
		SEG_RECOVERY_DIRECTORY=${SEGMENT_DIR}/${DUMP_DIR}/${REMOTE_DATE}
		if [ $SEGMENT_DBID -eq -1 ];then
			SEG_RECOVERY_FILE=${MASTER_DBDUMP_PREFIX}_${RESTORE_TIMESTAMP}
		else
			SEG_RECOVERY_FILE=${DBDUMP_PREFIX}0_${SEGMENT_DBID}_${RESTORE_TIMESTAMP}
		fi
		if [ x"" != x"$COMPRESS" ];then
			SEG_RECOVERY_FILE=${SEG_RECOVERY_FILE}.gz
		fi
		CHK_DIR ${SEGMENT_DIR}/${DUMP_DIR} $SEGMENT_HOST
		if [ $EXISTS -ne 0 ];then
			LOG_MSG "[INFO]:-Creating directory ${SEGMENT_DIR}/${DUMP_DIR} on $SEGMENT_HOST" 1
			$TRUSTED_SHELL $SEGMENT_HOST "$MKDIR ${SEGMENT_DIR}/${DUMP_DIR}"
			RETVAL=$?
			if [ $RETVAL -ne 0 ];then
				ERROR_EXIT "[FATAL]:-Failed to create directory ${SEGMENT_DIR}/${DUMP_DIR} on $SEGMENT_HOST" 2
			fi
		fi
		CHK_DIR $SEG_RECOVERY_DIRECTORY $SEGMENT_HOST
		if [ $EXISTS -ne 0 ];then
			LOG_MSG "[INFO]:-Creating directory $SEG_RECOVERY_DIRECTORY on $SEGMENT_HOST" 1
			$TRUSTED_SHELL $SEGMENT_HOST "$MKDIR $SEG_RECOVERY_DIRECTORY"
			RETVAL=$?
			if [ $RETVAL -ne 0 ];then
				ERROR_EXIT "[FATAL]:-Failed to create directory $SEG_RECOVERY_DIRECTORY on $SEGMENT_HOST" 2
			fi
		fi
		LOG_MSG "[INFO]:-Commencing remote copy from $DB_HOST to ${SEGMENT_HOST}:$SEG_RECOVERY_DIRECTORY" 1
		$TRUSTED_SHELL $SEGMENT_HOST "$SCP ${DB_HOST}:${DB_HOST_PATH}/$SEG_RECOVERY_FILE $SEG_RECOVERY_DIRECTORY" 
		RETVAL=$?
		if [ $RETVAL -ne 0 ];then
			ERROR_EXIT "[FATAL]:-Failed to $SCP ${DB_HOST_PATH}/$SEG_RECOVERY_FILE to $SEGMENT_HOST" 2
		else
			LOG_MSG "[INFO]:-Completed $SEG_RECOVERY_FILE copy to $SEGMENT_HOST" 1
		fi
	done
	#Now process Master create database file
		#$TRUSTED_SHELL $QD_NAME "$SCP ${DB_HOST}:${DB_HOST_PATH}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP} ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${REM_DATE}"
		$TRUSTED_SHELL $QD_NAME "$SCP ${DB_HOST}:${DB_HOST_PATH}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP} ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${REMOTE_DATE}"
		RETVAL=$?
		if [ $RETVAL -ne 0 ];then
			ERROR_EXIT "[FATAL]:-Failed to $SCP ${DB_HOST_PATH}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP} to ${QD_NAME}" 2
		else
			LOG_MSG "[INFO]:-Completed ${CREATEDB_PREFIX}${RESTORE_TIMESTAMP} copy to ${QD_NAME}" 1
		fi
		if [ $RESTORE_GLOBAL -eq 1 ];then
			#$TRUSTED_SHELL $QD_NAME "$SCP ${DB_HOST}:${DB_HOST_PATH}/${GLOBAL_OBJECT_PREFIX}${RESTORE_TIMESTAMP} ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${REM_DATE}"
			$TRUSTED_SHELL $QD_NAME "$SCP ${DB_HOST}:${DB_HOST_PATH}/${GLOBAL_OBJECT_PREFIX}${RESTORE_TIMESTAMP} ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${REMOTE_DATE}"
			if [ $? -ne 0 ];then
				LOG_MSG "[WARN]:-Failed to copy ${GLOBAL_OBJECT_PREFIX}${RESTORE_TIMESTAMP} file to $QD_NAME" 1
				EXIT_STATUS=1
			else
				LOG_MSG "[INFO]:-Completed ${GLOBAL_OBJECT_PREFIX}${RESTORE_TIMESTAMP} copy to ${QD_NAME}" 1
			fi
		fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

SET_VAR () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	SEG_HOSTNAME=`$ECHO $1|$CUT -d"|" -f1`
	SEG_DATADIR=`$ECHO $1|$CUT -d"|" -f2`
	SEG_DBID=`$ECHO $1|$CUT -d"|" -f6`
	SEG_VALID=`$ECHO $1|$CUT -d"|" -f4`
	SEG_DEFINED=`$ECHO $1|$CUT -d"|" -f5`
	SEG_CONTENT=`$ECHO $1|$CUT -d"|" -f7`
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

CHK_SEGMENT_DUMP_FILES () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#Expected dump file name is gp_dump_0_${DBID}_${TIMESTAMP}[.gz]
	PRIMARY_DUMP_COUNT=0
	DUMP_FILE_COUNT=0
	SEG_INVALID_COUNT=0
	for QE_LINE in "${PRIMARY_QE_ARRAY[@]}"
	do
		SET_VAR $QE_LINE
		if [ x"" != x"$DB_FILE_HOST" ];then
			REM_DIR=${RESTORE_DIR}
			CHK_HOSTNAME=$DB_HOST
		else
			REM_DIR=${SEG_DATADIR}/${DUMP_DIR}/$RESTORE_DIR_DATE
			CHK_HOSTNAME=$SEG_HOSTNAME
		fi
		if [ x"" == x"$COMPRESS" ];then
			CHK_FILE ${REM_DIR}/${DBDUMP_PREFIX}0_${SEG_DBID}_${RESTORE_TIMESTAMP} $CHK_HOSTNAME
		else
			CHK_FILE ${REM_DIR}/${DBDUMP_PREFIX}0_${SEG_DBID}_${RESTORE_TIMESTAMP}.gz $CHK_HOSTNAME
		fi
		if [ $EXISTS -eq 0 ];then
			if [ $SEG_DEFINED == "t" ];then
				((PRIMARY_DUMP_COUNT=$PRIMARY_DUMP_COUNT+1))
				PRI_DBID_LIST="$PRI_DBID_LIST $SEG_DBID"
				PRI_CONTENT_LIST="$PRI_CONTENT_LIST $SEG_CONTENT"
			else
				ERROR_EXIT "[FATAL]:-Internal Error: searched for mirror dump files." 2
			fi
			if [ $SEG_VALID == "f" ];then
				ERROR_EXIT "[FATAL]:-Host $CHK_HOSTNAME dir $SEG_DATADIR dbid $SEG_DBID marked as invalid" 2
			else
				CONTENT_DBID_MAP="${CONTENT_DBID_MAP} ${SEG_CONTENT}:${SEG_DBID}"
			fi
			LOG_MSG "[INFO]:-Located dump file for set $RESTORE_TIMESTAMP on $CHK_HOSTNAME in $REM_DIR" 1
			((DUMP_FILE_COUNT=$DUMP_FILE_COUNT+1))
			DBID_LIST="$DBID_LIST $SEG_DBID"
			CONTENT_LIST="$CONTENT_LIST $SEG_CONTENT"
			REMOTE_LIST="$REMOTE_LIST ${SEG_HOSTNAME}:${SEG_DBID}:${SEG_DATADIR}"
		else
			LOG_MSG "[INFO]:-No dump file on $SEG_HOSTNAME in $REM_DIR, skipping" 
		fi
	done
	#Add Master dbid to DBID_LIST
	DBID_LIST="1${DBID_LIST}"
	CONTENT_LIST="-1${CONTENT_LIST}"
	REMOTE_LIST="${QD_NAME}:-1:${MASTER_DATA_DIRECTORY}$REMOTE_LIST"
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

VALIDATE_DBID_LIST () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	LOG_MSG "[INFO]:-Obtained dbid list $DBID_LIST"
	((TOTAL_DUMP_COUNT=$PRIMARY_DUMP_COUNT))
	TOTAL_SEG=${#PRIMARY_QE_ARRAY[@]}
	#all primaries or combination restore check
	if [ $TOTAL_DUMP_COUNT -eq $TOTAL_PRIMARY_SEGMENTS ];then
		#Have all primaries dump file set
		RESTORE_TYPE="All segments"
		RESTORE_NUM=1
	else
		LOG_MSG "[WARN]:-Do not have a full primary dump file set for all primary segments"
		RESTORE_TYPE="Partial [Changed due to missing dump files]"
		FIND_VALID_RESTORE_SET
		RESTORE_NUM=2
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

FIND_VALID_RESTORE_SET () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#See if we have a complete set in there somewhere
	CONTENT_UNIQUE=`$ECHO $MIR_CONTENT_LIST $PRI_CONTENT_LIST|$TR ' ' '\n'|$SORT -u|$WC -l`
	if [ $CONTENT_UNIQUE -ne $TOTAL_PRI ];then	
		LOG_MSG "[FATAL]:-There are insufficient dump files to generate a valid restore file set" 1
		LOG_MSG "[INFO]:-Try looking for another timestamp value, or restore additional dump files" 1
		ERROR_EXIT "[FATAL]:-Unable to continue" 2
	else
		LOG_MSG "[INFO]:-Initial checks indicate that a valid restore file set can be generated, processing.." 1
	fi
	DBID_LIST=""
	CONTENT_VALUES=`$ECHO $MIR_CONTENT_LIST $PRI_CONTENT_LIST|$TR ' ' '\n'|$SORT -u|$TR '\n' ' '`
	for I in $CONTENT_VALUES
	do
		for J in $CONTENT_DBID_MAP 
		do
			if [ `$ECHO $J|$AWK -F":" '{print $1}'` == $I ];then
				DBID_LIST="${DBID_LIST} `$ECHO $J|$AWK -F":" '{print $2}'`"
				break
			fi
		done
	done
	CONTENT_LIST=$CONTENT_VALUES
	DBID_LIST="1${DBID_LIST}"
	LOG_MSG "[INFO]:-Successfully generated a valid restore file set" 1
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

SEARCH_FOR_LATEST_DUMP_SET () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	LOG_MSG "[INFO]:-Scanning Master host for lastest dump file set for database $SEARCH_FOR_DBNAME" 1
	#Build an array of gp_cdatabase_1_1 files
	CDATABASE_ARRAY=(`$FIND ${MASTER_DATA_DIRECTORY}/${DUMP_DIR} -name "${CREATEDB_PREFIX}*"`)
	if [ ${#CDATABASE_ARRAY[@]} -eq 0 ];then
		ERROR_EXIT "[FATAL]:-No ${CREATEDB_PREFIX}* files located" 2
	fi
	for CFILE in ${CDATABASE_ARRAY[@]}
	do
		DB_LOCATED=`$CAT $CFILE|$TR -d '"'|$GREP -i "create database"|grep -ic "$SEARCH_FOR_DBNAME"`
		if [ $DB_LOCATED -ne 0 ];then
			#Now see if we have the correct database name
			#Expect the database name to the the 3rd word in the file
			DB_NAME_IN_FILE=`$CAT $CFILE|$TR -d '"'|$GREP -i "create database"|$AWK '{print $3}'`
			if [ $DB_NAME_IN_FILE == $SEARCH_FOR_DBNAME ];then
				LOG_MSG "[INFO]:-Located dump file $CFILE for database $SEARCH_FOR_DBNAME, adding to list" 1
				TO_CHECK=(${TO_CHECK[@]} $CFILE)
			else
				LOG_MSG "[INFO]:-Dump file has incorrect database name of $DB_NAME_IN_FILE, skipping.." 1
			fi
		fi
	done
	if [ ${#TO_CHECK[@]} -eq 0 ];then
		ERROR_EXIT "[FATAL]:-No ${CREATEDB_PREFIX}* files located with database $SEARCH_FOR_DBNAME" 2
	else
		LOG_MSG "[INFO]:-Located ${#TO_CHECK[@]} ${CREATEDB_PREFIX}* files with database $SEARCH_FOR_DBNAME" 1
	fi
	CMAX_DATE=0
	for CFILE in ${TO_CHECK[@]}
	do
		CDATE=`$ECHO $CFILE|$AWK -F"/" '{print $NF}'|$AWK -F"_" '{print $NF}'`
		if [ $CDATE -gt $CMAX_DATE ];then
			CMAX_DATE=$CDATE
		fi
	done
	RESTORE_TIMESTAMP=$CMAX_DATE
	DB_DATE_DIR=`$ECHO $CMAX_DATE|$CUT -c1-8`
	RESTORE_DIR_DATE=$DB_DATE_DIR
	GP_RESTORE_DIR=${DUMP_DIR}/$DB_DATE_DIR	
	RESTORE_DIR=${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR
	COMPRESS=`ls ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$DB_DATE_DIR/${MASTER_DBDUMP_PREFIX}_${RESTORE_TIMESTAMP}*|$AWK -F"." '{print $2}'`
	RESTORE_DIR_DATE=$DB_DATE_DIR
	LOG_MSG "[INFO]:-Identified latest dump timestamp for $SEARCH_FOR_DBNAME as $CMAX_DATE" 1
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

GATHER_INFO () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	GET_MIRROR_TYPE
	if [ x"" != x"$DB_TIMESTAMP" ];then
		VALIDATE_TIMESTAMP
	fi
	if [ x"" != x"$DB_DATE_DIR" ];then
		VALIDATE_DB_DATE_DIR
	fi
	if [ x"" != x"$DB_FILE_HOST" ];then
		VALIDATE_DB_FILE_HOST
	fi
	if [ x"" != x"$SEARCH_FOR_DBNAME" ];then
		SEARCH_FOR_LATEST_DUMP_SET
	fi	
	#Get the current gp_fault_action setting
	FAIL_TYPE=`$EXPORT_LIB_PATH;env PGOPTIONS="-c gp_session_role=utility" $PSQL -p $MASTER_PORT "$DEFAULTDB" -R" " -A -t -c"show gp_fault_action;"`
	ERROR_CHK $? "obtain GPDB fault action setting" 2
	TOTAL_PRI=`$EXPORT_LIB_PATH;env PGOPTIONS="-c gp_session_role=utility" $PSQL -p $MASTER_PORT "$DEFAULTDB" -R" " -A -t -c"select count(*) from $CONFIG_TABLE as _gp_config where content<>-1 and preferred_role='p';"`
	ERROR_CHK $? "obtain total number of primary segment hosts" 2
	#Now get name of database we are going to restore
	if [ x"" = x"$DB_FILE_HOST" ];then
		CHK_FILE ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${RESTORE_DIR_DATE}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP}
	else
		CHK_FILE ${RESTORE_DIR}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP} $DB_HOST
	fi
	if [ $EXISTS -eq 0 ];then
		CREATEDB_FILE=${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${RESTORE_DIR_DATE}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP}
		if [ x"" = x"$DB_FILE_HOST" ];then
		RESTORE_DBNAME=`$CAT ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/${RESTORE_DIR_DATE}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP}|$TR -d '"'|$GREP -i "create database"|$AWK '{print $3}'`
		else
		RESTORE_DBNAME=`$TRUSTED_SHELL $DB_HOST "$CAT ${RESTORE_DIR}/${CREATEDB_PREFIX}${RESTORE_TIMESTAMP}|$TR -d '\"'|$GREP -i 'create database'"|$AWK '{print $3}'`
		fi
	else
		ERROR_EXIT "[FATAL]:-Dump file ${CREATEDB_PREFIX}${RESTORE_TIMESTAMP} does not exist on Master" 2
	fi
	PRIMARY_QE_ARRAY=(`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select a.hostname, a.datadir, a.port, b.valid, b.isprimary, a.dbid, a.content from $CONFIG_TABLE a, $GP_PG_VIEW b where a.dbid=b.dbid and a.content<>-1 order by a.content;" 2>/dev/null`) > /dev/null 2>&1
	RETVAL=$?
	if [ $RETVAL -ne 0 ];then
		ERROR_EXIT "[FATAL]:-Failed to get segment details from database "$DEFAULTDB"" 2
	fi
	if [ $DROP_DB -eq 0 ];then
		DB_THERE=`$EXPORT_LIB_PATH;$PSQL -A -t -p $MASTER_PORT "$DEFAULTDB" -c"select count(*) from pg_database where datname='${RESTORE_DBNAME}';"`
		if [ $DB_THERE -eq 0 ];then
			ERROR_EXIT "[FATAL]:-Database ${RESTORE_DBNAME} does not exist and -e option not supplied" 2
		fi
	fi
	CHK_SEGMENT_DUMP_FILES
	VALIDATE_DBID_LIST
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

BUILD_RESTORE_LINE () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	DBID_LINE="[`$ECHO $DBID_LIST|$TR ' ' ','`]"
	RESTORE_LINE="gp_restore -i -h $QD_NAME -p $MASTER_PORT -U $USER --gp-d=$GP_RESTORE_DIR --gp-i"
	case $RESTORE_NUM in
		1) #Primary only database restore
		   RESTORE_LINE="$RESTORE_LINE --gp-k=$RESTORE_TIMESTAMP --gp-r=$GP_RESTORE_DIR --gp-l=p"
		   ;;
		2) #Mixed restore  
		   LOG_MSG "[INFO]:-Re-configuring for primary restore" 1
		   SWITCH_TO_PRIMARY
		   RESTORE_LINE="$RESTORE_LINE --gp-k=$RESTORE_TIMESTAMP --gp-r=$GP_RESTORE_DIR --gp-l=p"
		   ;;
	esac
	if [ x"" != x"$COMPRESS" ];then
		RESTORE_LINE="$RESTORE_LINE --gp-c"
	fi
	RESTORE_LINE="$RESTORE_LINE -d $RESTORE_DBNAME"
	LOG_MSG "[INFO]:-Restore command line built" 1
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

SWITCH_TO_PRIMARY () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	if [ x"" == x"$COMPRESS" ];then
		SUFFIX=""
	else
		SUFFIX=".gz"
	fi
	for DBID in ${DBID_LIST[@]}
	do
		LOG_MSG "[INFO]:-Processing DBID = $DBID"
		IS_MIRROR=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select case when preferred_role='p' then 'f' else 't' end from $CONFIG_TABLE as a where dbid=$DBID;"`
		if [ $IS_MIRROR == 'f' ];then
			M_HOST=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select hostname from $CONFIG_TABLE as a where dbid=$DBID;"`
			M_CONTENT=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select content from $CONFIG_TABLE as a where dbid=$DBID;"`
			M_DIR=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select
 datadir from $CONFIG_TABLE where dbid=$DBID;"`
			P_HOST=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select hostname from $CONFIG_TABLE as a where content=$M_CONTENT and preferred_role='p';"`
			P_DIR=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select
 datadir from $CONFIG_TABLE as a where content=$M_CONTENT and preferred_role='p';"`
			P_DBID=`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select
 dbid from $CONFIG_TABLE as a where content=$M_CONTENT and preferred_role='p';"`
			#Check if we have remote db_dumps directory
			CHK_DIR ${P_DIR}/${DUMP_DIR} $P_HOST
			if [ $EXISTS -ne 0 ];then
				$TRUSTED_SHELL $P_HOST "$MKDIR ${P_DIR}/${DUMP_DIR}"
				ERROR_CHK $? "make directory ${P_DIR}/${DUMP_DIR} on $P_HOST" 2;fi
			CHK_DIR ${P_DIR}/${DUMP_DIR}/${RESTORE_DIR_DATE} $P_HOST
			if [ $EXISTS -ne 0 ];then
				$TRUSTED_SHELL $P_HOST "$MKDIR ${P_DIR}/${DUMP_DIR}/${RESTORE_DIR_DATE}"
				ERROR_CHK $? "make directory ${P_DIR}/${DUMP_DIR}/${RESTORE_DIR_DATE} on $P_HOST" 2;fi
			$TRUSTED_SHELL $M_HOST "$TRUSTED_COPY -p ${M_DIR}/${DUMP_DIR}/${RESTORE_DIR_DATE}/${DBDUMP_PREFIX}0_${DBID}_${RESTORE_TIMESTAMP}$SUFFIX ${P_HOST}:${P_DIR}/${DUMP_DIR}/${RESTORE_DIR_DATE}/${DBDUMP_PREFIX}0_${P_DBID}_${RESTORE_TIMESTAMP}$SUFFIX"
			if [ $? -ne 0 ];then
				ERROR_EXIT "[FATAL]:-Failed to copy dump file from $M_HOST to ${P_HOST}:${P_DIR}/${DUMP_DIR}/${RESTORE_DIR_DATE}" 2
			else
				LOG_MSG "[INFO]:-Successfully copied dump file to primary segment host $P_HOST" 1
			fi
		fi
	done
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}
	
PROCESS_CREATEDB () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#Check if the database exists
	DB_THERE=`$EXPORT_LIB_PATH;$PSQL -A -t -p $MASTER_PORT "$DEFAULTDB" -c"select count(*) from pg_database where datname='${RESTORE_DBNAME}';"`
	if [ $DB_THERE -eq 1 ];then
		LOG_MSG "[INFO]:-Dropping database $RESTORE_DBNAME" 1 
		$EXPORT_LIB_PATH;$PSQL -p $MASTER_PORT "$DEFAULTDB" -c"drop database \"${RESTORE_DBNAME}\";"
		RETVAL=$?
		if [ $RETVAL -ne 0 ];then
			ERROR_EXIT "[FATAL]:-Failed to drop database ${RESTORE_DBNAME}" 2
		else
			LOG_MSG "[INFO]:-Completed drop of ${RESTORE_DBNAME} database" 1
		fi
	fi
	LOG_MSG "[INFO]:-Calling $CREATEDB_FILE" 1
	$EXPORT_LIB_PATH;$PSQL -A -t -p $MASTER_PORT "$DEFAULTDB" -f $CREATEDB_FILE
	RETVAL=$?
	if [ $RETVAL -ne 0 ];then
		ERROR_EXIT "[FATAL]:-Failed to create database ${RESTORE_DBNAME}" 2 	
	else
		LOG_MSG "[INFO]:-Completed creation of ${RESTORE_DBNAME} database" 1
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

RESTORE_GLOBAL_DUMP () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	LOG_MSG "[INFO]:-Commencing restore of global objects" 1
	CHK_FILE ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$RESTORE_DIR_DATE/${GLOBAL_OBJECT_PREFIX}$RESTORE_TIMESTAMP
	if [ $EXISTS -eq 0 ];then
		$EXPORT_LIB_PATH;$PSQL -A -t -p $MASTER_PORT "$DEFAULTDB" -f ${MASTER_DATA_DIRECTORY}/${DUMP_DIR}/$RESTORE_DIR_DATE/${GLOBAL_OBJECT_PREFIX}$RESTORE_TIMESTAMP >> $LOG_FILE 2>&1
		if [ $? -ne 0 ];then
			LOG_MSG "[WARN]:-Issue with restore of global objects, check log file for details" 1
		else
			LOG_MSG "[INFO]:-Complete restore of global objects" 1
		fi
	else
		LOG_MSG "[WARN]:-Unable to locate ${GLOBAL_OBJECT_PREFIX}$RESTORE_TIMESTAMP file in dump set" 1
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

GP_RESTORE_DATABASE () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	if [ x"" == x"$RESTORE_TABLE" ];then
		LOG_MSG "[INFO]:-Commencing full restore of ${RESTORE_DBNAME} database, please wait..." 1
	else
		LOG_MSG "[INFO]:-Commencing specific table restores from dump files for database ${RESTORE_DBNAME}, please wait..." 1
	fi
	$RESTORE_LINE >> $LOG_FILE 2>&1
	RETVAL=$?
	if [ $RETVAL -ne 0 ];then
		ERROR_EXIT "[FATAL]:-Restore of ${RESTORE_DBNAME} failed, check log file" 2
	else
		LOG_MSG "[INFO]:-Restore of ${RESTORE_DBNAME} completed without error" 1
	fi
	if [ ${NOANALYZE} ] 
	then
		LOG_MSG "[WARN]:---------------------------------------------------------------------------------------------------" 1
		LOG_MSG "[WARN]:-Analyze bypassed on request; database performance may be adversely impacted until analyze is done." 1
		LOG_MSG "[WARN]:---------------------------------------------------------------------------------------------------" 1
	elif [ x"" == x"$RESTORE_TABLE" ];then
		LOG_MSG "[INFO]:-Commencing analyze of ${RESTORE_DBNAME} database, please wait..." 1
		$EXPORT_LIB_PATH;$PSQL -A -t -p $MASTER_PORT "$RESTORE_DBNAME" -c"analyze;" >> $LOG_FILE 2>&1
		if [ $? -ne 0 ];then
			LOG_MSG "[WARN]:-Issue with analyze of $RESTORE_DBNAME database, check log file for details" 1
			EXIT_STATUS=1
		else
			LOG_MSG "[INFO]:-Analyze of $RESTORE_DBNAME completed without error" 1
		fi
	else
		for RESTORE_TAB_NAME in "${RESTORE_LIST[@]}"
		do
			LOG_MSG "[INFO]:-Commencing analyze of table $RESTORE_TAB_NAME in ${RESTORE_DBNAME} database, please wait..." 1
			$EXPORT_LIB_PATH;$PSQL -A -t -p $MASTER_PORT "$RESTORE_DBNAME" -c"analyze ${RESTORE_TAB_NAME};" >> $LOG_FILE 2>&1
			if [ $? -ne 0 ];then
				LOG_MSG "[WARN]:-Issue with analyze of $RESTORE_TAB_NAME table, check log file for details" 1
				EXIT_STATUS=1
			else
				LOG_MSG "[INFO]:-Analyze of $RESTORE_TAB_NAME table completed without error" 1
			fi
		done

	fi
	LOG_MSG "[INFO]:-Restore of $RESTORE_DBNAME completed without error" 1
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

CHK_RESTORE_TABLE () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	LOG_MSG "[INFO]:-Checking list of tables for restore, please wait..." 1
	local oldIFS="${IFS}"
	IFS=','
	RESTORE_TABLE_ARRAY=($RESTORE_TABLE)
	IFS="${oldIFS}"
	for RESTORE_ITEM in "${RESTORE_TABLE_ARRAY[@]}"
	do
		if [ `$ECHO $RESTORE_ITEM|$GREP -c "\."` -eq 1 ];then
			#Schema name has been supplied, can continue
			CHK_EXISTS_TABLE "$RESTORE_ITEM" $MASTER_PORT $RESTORE_DBNAME
			if [ $EXISTS -eq 1 ];then
				LOG_MSG "[WARN]:-Table $RESTORE_ITEM does not exist in database $RESTORE_DBNAME, removing from list of tables to restore" 1
			else
				#Check if table has a non-zero size
				TAB_COUNT=`${EXPORT_LIB_PATH}; $PSQL -A -t -q -p $MASTER_PORT "$RESTORE_DBNAME" -A -t -c"select count(*) from $RESTORE_ITEM;"` >> $LOG_FILE 2>&1
				if [ $TAB_COUNT -ne 0 ];then
					LOG_MSG "[WARN]:-Table $RESTORE_ITEM has $TAB_COUNT records $WARN_MARK" 1
					TAB_COUNT_ARRAY[${#TAB_COUNT_ARRAY[@]}]="${RESTORE_ITEM}:$TAB_COUNT"
				fi
				RESTORE_LIST[${#RESTORE_LIST[@]}]="$RESTORE_ITEM"
			fi 
		else
			LOG_MSG "[WARN]:-No schema name supplied for $RESTORE_ITEM, removing from list of tables to restore" 1
		fi
	done 
	if [ "${#RESTORE_LIST[@]}" -eq 0 ];then
		ERROR_EXIT "[FATAL]:-Have no tables to restore" 2
	else
		LOG_MSG "[INFO]:-Have ${#RESTORE_LIST[@]} tables to restore, will continue" 1
	fi
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

GP_RESTORE_TABLE () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	#Create a fake timestamp for restore dump files
	TABLE_TIMESTAMP=`$DATE +%Y%m%d%H%M%S`
	BATCH_LIMIT=${#PRIMARY_QE_ARRAY[@]}
	#Get segment details from the contents of DBID_LIST
	DBID_TXT=`$ECHO $DBID_LIST|$TR ' ' ','`
	TAB_ARRAY=(`${EXPORT_LIB_PATH};env PGOPTIONS="-c gp_session_role=utility" $PSQL -q -p $MASTER_PORT "$DEFAULTDB" -A -t -c"select hostname, datadir, dbid from $CONFIG_TABLE as _gp_config where dbid in (${DBID_TXT}) and content<>-1 order by port;"`)
	if [ $BATCH_DEFAULT -gt $BATCH_LIMIT ];then
		RESET_BATCH_VALUE
	fi
	if [ x"" == x"$COMPRESS" ];then
		ZIPPED=0
	else
		ZIPPED=1
	fi
	MODE=0
	RUN_PARALLEL
	if [ $REPORT_FAIL -ne 0 ];then
		ERROR_EXIT "[FATAL]:-Parallel table dump file build failed, review log file for details" 2
	fi
	#Now build a fake master dump file to run
	if [ x"" == x"$COMPRESS" ];then
		SHOW_CMD=$CAT
		T_SUFFIX=""
	else
		SHOW_CMD=$ZCAT
		T_SUFFIX=".gz"
	fi
	M_DUMP_FILE=${MASTER_DATA_DIRECTORY}/$GP_RESTORE_DIR/gp_dump_1_1_${RESTORE_TIMESTAMP}${T_SUFFIX}
	T_DUMP_FILE=${MASTER_DATA_DIRECTORY}/$GP_RESTORE_DIR/gp_dump_1_1_${TABLE_TIMESTAMP}
	$SHOW_CMD $M_DUMP_FILE|$HEAD -20|$AWK 'BEGIN {output=0} {if ($1=="SET") output=1} {if ($1!="SET") output=0} {if (output==1) print $0}' >> $T_DUMP_FILE >> $LOG_FILE 2>&1
	if [ x"" != x"$COMPRESS" ];then
		unset COMPRESS
	fi
	RESTORE_TIMESTAMP=${TABLE_TIMESTAMP}
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

RUN_PARALLEL () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	PARALLEL_SETUP  $PARALLEL_STATUS_FILE
	for TNODE in "${TAB_ARRAY[@]}"
	do
		if [ $DEBUG_LEVEL -eq 0 ] && [ x"" != x"$VERBOSE" ];then $NOLINE_ECHO ".\c";fi
		TSET_VAR
		local oldIFS="${IFS}"
		IFS=','
		local rlist="${RESTORE_LIST[*]}"
		IFS="${oldIFS}"
		$GPSEGDBRESTORE $$ $QE_NAME $QE_DIR $QE_DBID $INST_COUNT $LOG_FILE $RESTORE_TIMESTAMP $TABLE_TIMESTAMP \
				$PARALLEL_STATUS_FILE $GP_RESTORE_DIR $ZIPPED $MODE "${rlist}" &
		PARALLEL_COUNT $BATCH_LIMIT $BATCH_DEFAULT
	done
	if [ $DEBUG_LEVEL -eq 0 ];then $NOLINE_ECHO;fi
	$CAT $PARALLEL_STATUS_FILE >> $LOG_FILE
	PARALLEL_SUMMARY_STATUS_REPORT
	$RM -f $PARALLEL_STATUS_FILE
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}
	
TSET_VAR () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	QE_NAME=`$ECHO $TNODE|$AWK -F"|" '{print $1}'`
	QE_DIR=`$ECHO $TNODE|$AWK -F"|" '{print $2}'`
	QE_DBID=`$ECHO $TNODE|$AWK -F"|" '{print $3}'`
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

CLEAR_RESTORE_TABLE_DUMP_FILES () {
	LOG_MSG "[INFO]:-Start Function $FUNCNAME"
	LOG_MSG "[INFO]:-Commencing deletion of temporary table dump restore files" 1
	MODE=1
	RUN_PARALLEL
	$RM -f $T_DUMP_FILE
	LOG_MSG "[INFO]:-End Function $FUNCNAME"
}

#******************************************************************************
# Main Section
#******************************************************************************
trap 'ERROR_EXIT "[FATAL]:-Received INT or TERM signal" 2' INT TERM
if [ $# -ne 0 ]; then
	while getopts ":vt:'?'aql:d:!Dt:b:R:es:GT:B:KL-:" opt;do
	case $opt in
		v ) VERSION_INFO ;;
		'?' ) USAGE ;;
		! ) SCRIPT_USAGE=1
		    USAGE ;;
		d ) MASTER_DATA_DIRECTORY=$OPTARG ;;
		a ) unset INTERACTIVE ;;
		q ) unset VERBOSE ;;
		l ) LOG_DIR=$OPTARG ;;
		D ) DEBUG_LEVEL=1 ;;
		t ) DB_TIMESTAMP=$OPTARG ;;
		b ) DB_DATE_DIR=$OPTARG ;;
		R ) DB_FILE_HOST=$OPTARG ;;
		e ) DROP_DB=1 ;;
		s ) SEARCH_FOR_DBNAME=$OPTARG ;;
		G ) RESTORE_GLOBAL=1 ;;
		T ) RESTORE_TABLE=$OPTARG ;;
		B ) BATCH_DEFAULT=$OPTARG ;;
		K ) KEEP_DUMP_FILES=1 ;;
		L ) LIST_TABLES=1 ;;
		- ) # Long options ...
			case ${OPTARG} in
				noanalyze ) NOANALYZE=1 ;;
				* ) USAGE ;;
			esac
			;;
		* ) USAGE ;;
	esac
	done	
fi
if [ x"" != x"$LOG_DIR" ];then
	CHK_DIR $LOG_DIR
	if [ $EXISTS -eq 1 ]; then
		LOG_MSG "[WARN]:-Log directory $LOG_DIR does not exist, using default log directory" 1
	else
		LOG_FILE=$LOG_DIR/${PROG_NAME}_${CUR_DATE}.log
	fi
fi
LOG_MSG "[INFO]:-Start Main"
LOG_MSG "[INFO]:-Command line options passed to utility = $*"
CHK_GPDB_ID
if [ x"" != x"$GPHOME" ];then
	APP_PATH=${GPHOME}/bin
else
	ERROR_EXIT "[FATAL]:-Environment variable \$GPHOME unset" 2
fi
#Check to ensure mandatory parameters have been supplied
CHK_ON_PASSIVE_STANDBY
#GET_QD_DB_NAME
CHK_PARAM
if [ x"" != x"$SEARCH_FOR_DBNAME" ];then
	unset DB_TIMESTAMP
	unset DB_DATE_DIR
	unset DB_FILE_HOST
fi
VALIDATE_PARAMS
if [ x"" != x"$DB_TIMESTAMP" ] && [ x"" != x"$LIST_TABLES" ];then
	LIST_DUMP_TABLES
fi
PRE_RESTORE_CHECKS
GATHER_INFO
if [ x"" != x"$RESTORE_TABLE" ];then
	GET_MASTER_PORT $MASTER_DATA_DIRECTORY
	CHK_RESTORE_TABLE
fi
if [ x"" != x"$INTERACTIVE" ];then
	PROMPT_CONTINUE
fi
if [ x"" != x"$DB_FILE_HOST" ];then
	RECOVER_REMOTE_DUMP_FILES
fi
if [ $DROP_DB -eq 1 ];then
	PROCESS_CREATEDB
fi
if [ x"" == x"$RESTORE_TABLE" ];then
	BUILD_RESTORE_LINE
	if [ $RESTORE_GLOBAL -eq 1 ];then
		RESTORE_GLOBAL_DUMP
	fi
	GP_RESTORE_DATABASE
else
	GP_RESTORE_TABLE
	BUILD_RESTORE_LINE
	GP_RESTORE_DATABASE
	if [ x"" == x"$KEEP_DUMP_FILES" ];then
		CLEAR_RESTORE_TABLE_DUMP_FILES
	fi
fi
LOG_MSG "[INFO]:-End Main"
exit $EXIT_STATUS
