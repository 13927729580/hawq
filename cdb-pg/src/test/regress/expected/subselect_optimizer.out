--
-- SUBSELECT
--
SELECT 1 AS one WHERE 1 IN (SELECT 1);
 one 
-----
   1
(1 row)

SELECT 1 AS zero WHERE 1 NOT IN (SELECT 1);
 zero 
------
(0 rows)

SELECT 1 AS zero WHERE 1 IN (SELECT 2);
 zero 
------
(0 rows)

-- Set up some simple test tables
CREATE TABLE SUBSELECT_TBL (
  f1 integer,
  f2 integer,
  f3 float
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
SELECT '' AS eight, * FROM SUBSELECT_TBL ORDER BY 2,3,4;
 eight | f1 | f2 | f3 
-------+----+----+----
       |  1 |  1 |  1
       |  1 |  2 |  3
       |  2 |  2 |  2
       |  2 |  3 |  4
       |  3 |  3 |  3
       |  3 |  4 |  5
       |  6 |  7 |  8
       |  8 |  9 |   
(8 rows)

-- Uncorrelated subselects
SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT 1) ORDER BY 2;
 two | Constant Select 
-----+-----------------
     |               1
     |               1
(2 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL) ORDER BY 2;
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  1
     |                  2
     |                  2
     |                  3
     |                  3
(6 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
    f2 IN (SELECT f1 FROM SUBSELECT_TBL)) ORDER BY 2;
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  1
     |                  2
     |                  2
     |                  3
     |                  3
(6 rows)

SELECT '' AS three, f1, f2
  FROM SUBSELECT_TBL
  WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                         WHERE f3 IS NOT NULL) ORDER BY 2,3;
 three | f1 | f2 
-------+----+----
       |  1 |  2
       |  6 |  7
       |  8 |  9
(3 rows)

-- Correlated subselects
SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1) ORDER BY 2,3;
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            1
     |                1 |            2
     |                2 |            2
     |                2 |            3
     |                3 |            3
     |                3 |            4
(6 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN
    (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3) ORDER BY 2,3;
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            1
     |                2 |            2
     |                2 |            4
     |                3 |            3
     |                3 |            5
(5 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
               WHERE f2 = CAST(f3 AS integer)) ORDER BY 2,3;
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            3
     |                2 |            4
     |                3 |            5
     |                6 |            8
(4 rows)

SELECT '' AS five, f1 AS "Correlated Field"
  FROM SUBSELECT_TBL
  WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                     WHERE f3 IS NOT NULL) ORDER BY 2;
 five | Correlated Field 
------+------------------
      |                1
      |                2
      |                2
      |                3
      |                3
(5 rows)

--
-- Use some existing tables in the regression test
--
SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
  FROM SUBSELECT_TBL ss
  WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
                   WHERE f1 != ss.f1 AND f1 < 2147483647) ORDER BY 2,3;
 eight | Correlated Field | Second Field 
-------+------------------+--------------
       |                2 |            2
       |                2 |            4
       |                3 |            3
       |                3 |            5
       |                6 |            8
       |                8 |             
(6 rows)

select q1, float8(count(*)) / (select count(*) from int8_tbl)
from int8_tbl group by q1 order by q1;
        q1        | ?column? 
------------------+----------
              123 |      0.4
 4567890123456789 |      0.6
(2 rows)

--
-- Test cases to catch unpleasant interactions between IN-join processing
-- and subquery pullup.
--
select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

--
-- Test cases to check for overenthusiastic optimization of
-- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
-- Luca Pireddu and Michael Fuhr.
--
CREATE TEMP TABLE foo (id integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TEMP TABLE bar (id1 integer, id2 integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO foo VALUES (1);
INSERT INTO bar VALUES (1, 1);
INSERT INTO bar VALUES (2, 2);
INSERT INTO bar VALUES (3, 1);
-- These cases require an extra level of distinct-ing above subquery s
SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM bar) AS s) ORDER BY 1;
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id1,id2 FROM bar GROUP BY id1,id2) AS s) ORDER BY 1;
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id1, id2 FROM bar UNION
                      SELECT id1, id2 FROM bar) AS s) ORDER BY 1;
 id 
----
  1
(1 row)

-- These cases do not
SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s) ORDER BY 1;
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM bar GROUP BY id2) AS s) ORDER BY 1;
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM bar UNION
                      SELECT id2 FROM bar) AS s) ORDER BY 1;
 id 
----
  1
(1 row)

--
-- Test case to catch problems with multiply nested sub-SELECTs not getting
-- recalculated properly.  Per bug report from Didier Moens.
--
CREATE TABLE orderstest (
    approver_ref integer,
    po_ref integer,
    ordercancelled boolean
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'approver_ref' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 5, false);
INSERT INTO orderstest VALUES (66, 6, false);
INSERT INTO orderstest VALUES (66, 7, false);
INSERT INTO orderstest VALUES (66, 1, true);
INSERT INTO orderstest VALUES (66, 8, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (77, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
CREATE VIEW orders_view AS
SELECT *,
(SELECT CASE
   WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
 END) AS "Approved",
(SELECT CASE
 WHEN ord.ordercancelled
 THEN 'Cancelled'
 ELSE
  (SELECT CASE
		WHEN ord.po_ref=1
		THEN
		 (SELECT CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END) 
END) AS "Status",
(CASE
 WHEN ord.ordercancelled
 THEN 'Cancelled'
 ELSE
  (CASE
		WHEN ord.po_ref=1
		THEN
		 (CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END) 
END) AS "Status_OK"
FROM orderstest ord;
SELECT * FROM orders_view ORDER BY 1,2,5;
 approver_ref | po_ref | ordercancelled | Approved |  Status   | Status_OK 
--------------+--------+----------------+----------+-----------+-----------
            1 |      1 | f              | ---      | ---       | ---
            1 |      1 | f              | ---      | ---       | ---
            1 |      1 | f              | ---      | ---       | ---
           66 |      1 | f              | Approved | Approved  | Approved
           66 |      1 | f              | Approved | Approved  | Approved
           66 |      1 | t              | Approved | Cancelled | Cancelled
           66 |      5 | f              | Approved | PO        | PO
           66 |      6 | f              | Approved | PO        | PO
           66 |      7 | f              | Approved | PO        | PO
           66 |      8 | f              | Approved | PO        | PO
           77 |      1 | f              | Approved | Approved  | Approved
(11 rows)

DROP TABLE orderstest cascade;
NOTICE:  drop cascades to rule _RETURN on view orders_view
NOTICE:  drop cascades to view orders_view
--
-- Test cases to catch situations where rule rewriter fails to propagate
-- hasSubLinks flag correctly.  Per example from Kyle Bateman.
--
create temp table parts (
    partnum     text,
    cost        float8
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'partnum' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create temp table shipped (
    ttype       char(2),
    ordnum      int4,
    partnum     text,
    value       float8
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ttype' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create temp view shipped_view as
    select * from shipped where ttype = 'wt';
create rule shipped_view_insert as on insert to shipped_view do instead
    insert into shipped values('wt', new.ordnum, new.partnum, new.value);
insert into parts (partnum, cost) values (1, 1234.56);
insert into shipped_view (ordnum, partnum, value)
    values (0, 1, (select cost from parts where partnum = 1));
select * from shipped_view ORDER BY 1,2;
 ttype | ordnum | partnum |  value  
-------+--------+---------+---------
 wt    |      0 | 1       | 1234.56
(1 row)

create rule shipped_view_update as on update to shipped_view do instead
    update shipped set partnum = new.partnum, value = new.value
        where ttype = new.ttype and ordnum = new.ordnum;
select * from shipped_view ORDER BY 1,2;
 ttype | ordnum | partnum |  value  
-------+--------+---------+---------
 wt    |      0 | 1       | 1234.56
(1 row)

select f1, ss1 as relabel from
    (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
     from int4_tbl a) ss;
     f1      |  relabel   
-------------+------------
      123456 | 2147607103
 -2147483647 |          0
           0 | 2147607103
     -123456 | 2147483647
  2147483647 | 2147483647
(5 rows)

--
-- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
-- Per bug report from David Sanchez i Gregori.
--
select * from (
  select max(unique1) from tenk1 as a
  where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
) ss;
 max  
------
 9997
(1 row)

select * from (
  select min(unique1) from tenk1 as a
  where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
) ss;
 min 
-----
   0
(1 row)

--
-- Base tables for CSQ tests
--
drop table if exists csq_t1_base;
NOTICE:  table "csq_t1_base" does not exist, skipping
create table csq_t1_base(x int, y int) distributed by (x);
insert into csq_t1_base values(1,2);
insert into csq_t1_base values(2,1);
insert into csq_t1_base values(4,2);
drop table if exists csq_t2_base;
NOTICE:  table "csq_t2_base" does not exist, skipping
create table csq_t2_base(x int, y int) distributed by (x);
insert into csq_t2_base values(3,2);
insert into csq_t2_base values(3,2);
insert into csq_t2_base values(3,2);
insert into csq_t2_base values(3,2);
insert into csq_t2_base values(3,1);
--
-- Correlated subqueries
--
drop table if exists csq_t1;
NOTICE:  table "csq_t1" does not exist, skipping
drop table if exists csq_t2;
NOTICE:  table "csq_t2" does not exist, skipping
create table csq_t1(x int, y int) distributed by (x);
create table csq_t2(x int, y int) distributed by (x);
insert into csq_t1 select * from csq_t1_base;
insert into csq_t2 select * from csq_t2_base;
select * from csq_t1 where csq_t1.x >ALL (select csq_t2.x from csq_t2 where csq_t2.y=csq_t1.y) order by 1; -- expected (4,2)
 x | y 
---+---
 4 | 2
(1 row)

--
-- correlations in the targetlist
--
select csq_t1.x, (select sum(bar.x) from csq_t1 bar where bar.x >= csq_t1.x) as sum from csq_t1 order by csq_t1.x;
 x | sum 
---+-----
 1 |   7
 2 |   6
 4 |   4
(3 rows)

select csq_t1.x, (select sum(bar.x) from csq_t1 bar where bar.x = csq_t1.x) as sum from csq_t1 order by csq_t1.x;
 x | sum 
---+-----
 1 |   1
 2 |   2
 4 |   4
(3 rows)

select csq_t1.x, (select bar.x from csq_t1 bar where bar.x = csq_t1.x) as sum from csq_t1 order by csq_t1.x;
 x | sum 
---+-----
 1 |   1
 2 |   2
 4 |   4
(3 rows)

--
-- CSQs with partitioned tables
--
drop table if exists csq_t1;
drop table if exists csq_t2;
create table csq_t1(x int, y int) 
distributed by (x)
partition by range (y) ( start (0) end (4) every (1))
;
NOTICE:  CREATE TABLE will create partition "csq_t1_1_prt_1" for table "csq_t1"
NOTICE:  CREATE TABLE will create partition "csq_t1_1_prt_2" for table "csq_t1"
NOTICE:  CREATE TABLE will create partition "csq_t1_1_prt_3" for table "csq_t1"
NOTICE:  CREATE TABLE will create partition "csq_t1_1_prt_4" for table "csq_t1"
create table csq_t2(x int, y int) 
distributed by (x)
partition by range (y) ( start (0) end (4) every (1))
;
NOTICE:  CREATE TABLE will create partition "csq_t2_1_prt_1" for table "csq_t2"
NOTICE:  CREATE TABLE will create partition "csq_t2_1_prt_2" for table "csq_t2"
NOTICE:  CREATE TABLE will create partition "csq_t2_1_prt_3" for table "csq_t2"
NOTICE:  CREATE TABLE will create partition "csq_t2_1_prt_4" for table "csq_t2"
insert into csq_t1 select * from csq_t1_base;
insert into csq_t2 select * from csq_t2_base;
explain select * from csq_t1 where csq_t1.x >ALL (select csq_t2.x from csq_t2 where csq_t2.y=csq_t1.y) order by 1;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=16)
   Sort Key: csq_t1.x
   ->  Result  (cost=0.00..2.03 rows=1 width=16)
         Filter: (subplan)
         ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.03 rows=1 width=16)
               ->  Sequence  (cost=0.00..1.02 rows=1 width=16)
                     ->  Result  (cost=10.00..100.00 rows=50 width=4)
                           ->  Function Scan on gp_partition_expansion  (cost=10.00..100.00 rows=50 width=4)
                     ->  Dynamic Table Scan on csq_t1 (partIndex: 0)  (cost=0.00..0.01 rows=1 width=16)
         SubPlan 1
           ->  Result  (cost=0.00..10.15 rows=1 width=1)
                 Filter: "ColRef_0027" = true
                 ->  Materialize  (cost=0.00..9.15 rows=1 width=8)
                       ->  Result  (cost=0.00..8.14 rows=1 width=8)
                             ->  Aggregate  (cost=0.00..7.14 rows=1 width=16)
                                   ->  Materialize  (cost=0.00..6.09 rows=1 width=16)
                                         ->  Result  (cost=0.00..5.08 rows=1 width=16)
                                               ->  Result  (cost=0.00..4.07 rows=1 width=8)
                                                     Filter: csq_t2.y = $1
                                                     ->  Materialize  (cost=0.00..3.06 rows=1 width=16)
                                                           ->  Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..2.03 rows=1 width=16)
                                                                 ->  Sequence  (cost=0.00..1.02 rows=1 width=16)
                                                                       ->  Result  (cost=10.00..100.00 rows=50 width=4)
                                                                             ->  Function Scan on gp_partition_expansion  (cost=10.00..100.00 rows=50 width=4)
                                                                       ->  Dynamic Table Scan on csq_t2 (partIndex: 1)  (cost=0.00..0.01 rows=1 width=16)
 Settings:  optimizer=on
(26 rows)

select * from csq_t1 where csq_t1.x >ALL (select csq_t2.x from csq_t2 where csq_t2.y=csq_t1.y) order by 1; -- expected (4,2)
 x | y 
---+---
 4 | 2
(1 row)

drop table if exists csq_t1;
drop table if exists csq_t2;
drop table if exists csq_t1_base;
drop table if exists csq_t2_base;
--
-- Multi-row subqueries
--
drop table if exists mrs_t1;
NOTICE:  table "mrs_t1" does not exist, skipping
create table mrs_t1(x int) distributed by (x);
insert into mrs_t1 select generate_series(1,20);
explain select * from mrs_t1 where exists (select x from mrs_t1 where x < -1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..85.12 rows=10 width=4)
   ->  Nested Loop EXISTS Join  (cost=0.00..84.08 rows=10 width=4)
         Join Filter: true
         ->  Table Scan on mrs_t1  (cost=0.00..0.04 rows=10 width=4)
         ->  Materialize  (cost=0.00..3.04 rows=1 width=1)
               ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.04 rows=1 width=1)
                     ->  Table Scan on mrs_t1  (cost=0.00..1.04 rows=1 width=1)
                           Filter: x < (-1)
 Settings:  optimizer=on
(9 rows)

select * from mrs_t1 where exists (select x from mrs_t1 where x < -1) order by 1;
 x 
---
(0 rows)

explain select * from mrs_t1 where exists (select x from mrs_t1 where x = 1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..85.12 rows=10 width=4)
   ->  Nested Loop EXISTS Join  (cost=0.00..84.08 rows=10 width=4)
         Join Filter: true
         ->  Table Scan on mrs_t1  (cost=0.00..0.04 rows=10 width=4)
         ->  Materialize  (cost=0.00..3.04 rows=1 width=1)
               ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.04 rows=1 width=1)
                     ->  Table Scan on mrs_t1  (cost=0.00..1.04 rows=1 width=1)
                           Filter: x = 1
 Settings:  optimizer=on
(9 rows)

select * from mrs_t1 where exists (select x from mrs_t1 where x = 1) order by 1;
 x  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
(20 rows)

explain select * from mrs_t1 where x in (select x-95 from mrs_t1) or x < 5;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..128055.46 rows=10 width=4)
   ->  Result  (cost=0.00..128054.42 rows=10 width=4)
         Filter: CASE WHEN NOT public.mrs_t1.x IS NULL THEN CASE WHEN "ColRef_0019" = "ColRef_0018" THEN NULL::boolean WHEN NOT "ColRef_0019" IS NULL THEN true ELSE false END ELSE NULL::boolean END OR public.mrs_t1.x < 5
         ->  GroupAggregate  (cost=0.00..128053.34 rows=200 width=20)
               Group By: public.mrs_t1.x, public.mrs_t1.ctid, public.mrs_t1.gp_segment_id
               ->  Nested Loop Left Join  (cost=0.00..128033.59 rows=200 width=28)
                     Join Filter: public.mrs_t1.x = "inner"."?column?" OR "inner"."?column?" IS NULL
                     ->  Sort  (cost=0.00..27.15 rows=10 width=20)
                           Sort Key: public.mrs_t1.x, public.mrs_t1.ctid, public.mrs_t1.gp_segment_id
                           ->  Table Scan on mrs_t1  (cost=0.00..0.20 rows=10 width=20)
                     ->  Materialize  (cost=0.00..5.45 rows=20 width=16)
                           ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..3.82 rows=20 width=16)
                                 ->  Result  (cost=0.00..2.51 rows=10 width=16)
                                       ->  Result  (cost=0.00..2.51 rows=10 width=16)
                                             ->  Result  (cost=0.00..1.20 rows=10 width=8)
                                                   ->  Table Scan on mrs_t1  (cost=0.00..0.04 rows=10 width=4)
 Settings:  optimizer=on
(17 rows)

select * from mrs_t1 where x in (select x-95 from mrs_t1) or x < 5 order by 1;
 x 
---
 1
 2
 3
 4
(4 rows)

drop table if exists mrs_t1;
--
-- Multi-row subquery from MSTR
--
drop table if exists mrs_u1;
NOTICE:  table "mrs_u1" does not exist, skipping
drop table if exists mrs_u2;
NOTICE:  table "mrs_u2" does not exist, skipping
create TABLE mrs_u1 (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create TABLE mrs_u2 (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into mrs_u1 values (1,2),(11,22);
insert into mrs_u2 values (1,2),(11,22),(33,44);
select * from mrs_u1 join mrs_u2 on mrs_u1.a=mrs_u2.a where mrs_u1.a in (1,11) or mrs_u2.a in (select a from mrs_u1 where a=1) order by 1;
 a  | b  | a  | b  
----+----+----+----
  1 |  2 |  1 |  2
 11 | 22 | 11 | 22
(2 rows)

drop table if exists mrs_u1;
drop table if exists mrs_u2;
--
-- MPP-13758
--
drop table if exists csq_m1;
NOTICE:  table "csq_m1" does not exist, skipping
create table csq_m1();
NOTICE:  Table has no attributes to distribute on.
alter table csq_m1 add column x int;
insert into csq_m1 values(1);
drop table if exists csq_d1;
NOTICE:  table "csq_d1" does not exist, skipping
create table csq_d1(x int) distributed by (x);
insert into csq_d1 select * from csq_m1;
explain select array(select x from csq_m1); -- no initplan
                          QUERY PLAN                          
--------------------------------------------------------------
 Result  (cost=1.01..1.02 rows=1 width=0)
   InitPlan
     ->  Seq Scan on csq_m1  (cost=0.00..1.01 rows=2 width=4)
 Settings:  optimizer=on
(4 rows)

select array(select x from csq_m1); -- {1}
 ?column? 
----------
 {1}
(1 row)

explain select array(select x from csq_d1); -- initplan
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Result  (cost=1.01..1.02 rows=1 width=0)
   InitPlan  (slice2)
     ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.01 rows=1 width=4)
           ->  Seq Scan on csq_d1  (cost=0.00..1.01 rows=1 width=4)
 Settings:  optimizer=on
(5 rows)

select array(select x from csq_d1); -- {1}
 ?column? 
----------
 {1}
(1 row)

--
-- CSQs involving master-only and distributed tables
--
drop table if exists t3coquicklz;
NOTICE:  table "t3coquicklz" does not exist, skipping
create table t3coquicklz (c1 int , c2 varchar) with (appendonly=true, compresstype=quicklz, orientation=column) distributed by (c1);
drop table if exists pg_attribute_storage;
NOTICE:  table "pg_attribute_storage" does not exist, skipping
create table pg_attribute_storage (attrelid int, attnum int, attoptions text[]) distributed by (attrelid);
insert into pg_attribute_storage values ('t3coquicklz'::regclass, 1, E'{\'something\'}');
insert into pg_attribute_storage values ('t3coquicklz'::regclass, 2, E'{\'something2\'}');
SELECT a.attname
, pg_catalog.format_type(a.atttypid, a.atttypmod)
, ( SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
 FROM pg_catalog.pg_attrdef d
WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef
)
, a.attnotnull
, a.attnum
, a.attstorage
, pg_catalog.col_description(a.attrelid, a.attnum)
, ( SELECT s.attoptions
FROM pg_attribute_storage s
WHERE s.attrelid = a.attrelid AND s.attnum = a.attnum
) newcolumn
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = 't3coquicklz'::regclass AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum
; -- expect to see 2 rows
 attname |    format_type    | ?column? | attnotnull | attnum | attstorage | col_description |   newcolumn    
---------+-------------------+----------+------------+--------+------------+-----------------+----------------
 c1      | integer           |          | f          |      1 | p          |                 | {'something'}
 c2      | character varying |          | f          |      2 | x          |                 | {'something2'}
(2 rows)

--
-- More CSQs involving master-only and distributed relations
--
drop table if exists csq_m1;
create table csq_m1();
NOTICE:  Table has no attributes to distribute on.
alter table csq_m1 add column x int;
insert into csq_m1 values(1),(2),(3);
drop table if exists csq_d1;
create table csq_d1(x int) distributed by (x);
insert into csq_d1 select * from csq_m1 where x < 3;
insert into csq_d1 values(4);
select * from csq_m1;
 x 
---
 1
 2
 3
(3 rows)

select * from csq_d1;
 x 
---
 2
 4
 1
(3 rows)

--
-- outer plan node is master-only and CSQ has distributed relation
--
explain select * from csq_m1 where x not in (select x from csq_d1) or x < -100; -- gather motion
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Result  (cost=0.00..2891.45 rows=2 width=4)
   Filter: CASE WHEN NOT csq_m1.x IS NULL THEN CASE WHEN "ColRef_0018" = "ColRef_0017" THEN NULL::boolean WHEN NOT "ColRef_0018" IS NULL THEN false ELSE true END ELSE NULL::boolean END OR csq_m1.x < (-100)
   ->  GroupAggregate  (cost=0.00..2890.42 rows=3 width=20)
         Group By: csq_m1.x, csq_m1.ctid, csq_m1.gp_segment_id
         ->  Nested Loop Left Join  (cost=0.00..2888.86 rows=3 width=28)
               Join Filter: csq_m1.x = csq_d1.x OR csq_d1.x IS NULL
               ->  Sort  (cost=0.00..4.77 rows=2 width=20)
                     Sort Key: csq_m1.ctid, csq_m1.gp_segment_id
                     ->  Table Scan on csq_m1  (cost=0.00..0.06 rows=2 width=20)
               ->  Materialize  (cost=0.00..3.09 rows=1 width=12)
                     ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.04 rows=1 width=12)
                           ->  Result  (cost=0.00..1.03 rows=1 width=12)
                                 ->  Result  (cost=0.00..1.03 rows=1 width=12)
                                       ->  Table Scan on csq_d1  (cost=0.00..0.00 rows=1 width=4)
 Settings:  optimizer=on
(15 rows)

select * from csq_m1 where x not in (select x from csq_d1) or x < -100; -- (3)
 x 
---
 3
(1 row)

--
-- outer plan node is master-only and CSQ has distributed relation
--
explain select * from csq_d1 where x not in (select x from csq_m1) or x < -100; -- broadcast motion
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..1448.49 rows=1 width=4)
   ->  Result  (cost=0.00..1447.48 rows=1 width=4)
         Filter: CASE WHEN NOT csq_d1.x IS NULL THEN CASE WHEN "ColRef_0018" = "ColRef_0017" THEN NULL::boolean WHEN NOT "ColRef_0018" IS NULL THEN false ELSE true END ELSE NULL::boolean END OR csq_d1.x < (-100)
         ->  GroupAggregate  (cost=0.00..1446.48 rows=3 width=20)
               Group By: csq_d1.x, csq_d1.ctid, csq_d1.gp_segment_id
               ->  Nested Loop Left Join  (cost=0.00..1445.20 rows=3 width=28)
                     Join Filter: csq_d1.x = csq_m1.x OR csq_m1.x IS NULL
                     ->  Sort  (cost=0.00..1.02 rows=1 width=20)
                           Sort Key: csq_d1.x, csq_d1.ctid, csq_d1.gp_segment_id
                           ->  Table Scan on csq_d1  (cost=0.00..0.02 rows=1 width=20)
                     ->  Materialize  (cost=0.00..3.18 rows=3 width=12)
                           ->  Result  (cost=0.00..2.11 rows=3 width=12)
                                 ->  Broadcast Motion 1:2  (slice1)  (cost=0.00..1.04 rows=6 width=4)
                                       ->  Table Scan on csq_m1  (cost=0.00..0.01 rows=2 width=4)
 Settings:  optimizer=on
(15 rows)

select * from csq_d1 where x not in (select x from csq_m1) or x < -100; -- (4)
 x 
---
 4
(1 row)

--
-- MPP-14441 Don't lose track of initplans
--
drop table if exists csq_t1;
NOTICE:  table "csq_t1" does not exist, skipping
CREATE TABLE csq_t1 (a int, b int, c int, d int, e text) DISTRIBUTED BY (a);
INSERT INTO csq_t1 SELECT i, i/3, i%2, 100-i, 'text'||i  FROM generate_series(1,100) i;
select count(*) from csq_t1 t1 where a > (SELECT x.b FROM ( select avg(a)::int as b,'haha'::text from csq_t1 t2 where t2.a=t1.d) x ) ;
 count 
-------
    49
(1 row)

select count(*) from csq_t1 t1 where a > ( select avg(a)::int from csq_t1 t2 where t2.a=t1.d) ;
 count 
-------
    49
(1 row)

--
-- correlation in a func expr
--
CREATE FUNCTION csq_f(a int) RETURNS int AS $$ select $1 $$ LANGUAGE SQL CONTAINS SQL;
CREATE TABLE csq_r(a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO csq_r VALUES (1);
-- subqueries shouldn't be pulled into a join if the from clause has a function call
-- with a correlated argument
-- force_explain
explain SELECT * FROM csq_r WHERE a IN (SELECT * FROM csq_f(csq_r.a));
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Result  (cost=0.00..1.00 rows=1 width=4)
   Filter: a = ((subplan))
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.00 rows=1 width=4)
         ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
   SubPlan 1
     ->  Result  (cost=0.00..1.02 rows=1 width=8)
           ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(8 rows)

SELECT * FROM csq_r WHERE a IN (SELECT * FROM csq_f(csq_r.a));
 a 
---
 1
(1 row)

-- force_explain
explain SELECT * FROM csq_r WHERE a not IN (SELECT * FROM csq_f(csq_r.a));
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Result  (cost=0.00..1.00 rows=1 width=4)
   Filter: a <> ((subplan))
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.00 rows=1 width=4)
         ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
   SubPlan 1
     ->  Result  (cost=0.00..1.02 rows=1 width=8)
           ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(8 rows)

SELECT * FROM csq_r WHERE a not IN (SELECT * FROM csq_f(csq_r.a));
 a 
---
(0 rows)

-- force_explain
explain SELECT * FROM csq_r WHERE exists (SELECT * FROM csq_f(csq_r.a));
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=4)
   ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=4)
         Filter: CASE WHEN "ColRef_0013" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0013", 0::bigint) END > 0::bigint
         ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=500 width=16)
               ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
               SubPlan 1
                 ->  Aggregate  (cost=0.00..2.02 rows=1 width=8)
                       ->  Result  (cost=0.00..1.00 rows=1 width=1)
                             ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(10 rows)

SELECT * FROM csq_r WHERE exists (SELECT * FROM csq_f(csq_r.a));
 a 
---
 1
(1 row)

-- force_explain
explain SELECT * FROM csq_r WHERE not exists (SELECT * FROM csq_f(csq_r.a));
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=4)
   ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=4)
         Filter: CASE WHEN "ColRef_0013" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0013", 0::bigint) END = 0::bigint
         ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=500 width=16)
               ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
               SubPlan 1
                 ->  Aggregate  (cost=0.00..2.02 rows=1 width=8)
                       ->  Result  (cost=0.00..1.00 rows=1 width=1)
                             ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(10 rows)

SELECT * FROM csq_r WHERE not exists (SELECT * FROM csq_f(csq_r.a));
 a 
---
(0 rows)

-- force_explain
explain SELECT * FROM csq_r WHERE a > (SELECT csq_f FROM csq_f(csq_r.a) limit 1);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Result  (cost=0.00..1.00 rows=1 width=4)
   Filter: a > ((subplan))
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.00 rows=1 width=4)
         ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
   SubPlan 1
     ->  Limit  (cost=0.00..2.03 rows=1 width=8)
           ->  Result  (cost=0.00..1.02 rows=1 width=8)
                 ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(9 rows)

SELECT * FROM csq_r WHERE a > (SELECT csq_f FROM csq_f(csq_r.a) limit 1);
 a 
---
(0 rows)

-- force_explain
explain SELECT * FROM csq_r WHERE a < ANY (SELECT csq_f FROM csq_f(csq_r.a));
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Result  (cost=0.00..1.00 rows=1 width=4)
   Filter: a < ((subplan))
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.00 rows=1 width=4)
         ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
   SubPlan 1
     ->  Result  (cost=0.00..1.02 rows=1 width=8)
           ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(8 rows)

SELECT * FROM csq_r WHERE a < ANY (SELECT csq_f FROM csq_f(csq_r.a));
 a 
---
(0 rows)

-- force_explain
explain SELECT * FROM csq_r WHERE a <= ALL (SELECT csq_f FROM csq_f(csq_r.a));
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Result  (cost=0.00..1.00 rows=1 width=4)
   Filter: a <= ((subplan))
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.00 rows=1 width=4)
         ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
   SubPlan 1
     ->  Result  (cost=0.00..1.02 rows=1 width=8)
           ->  Result  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(8 rows)

SELECT * FROM csq_r WHERE a <= ALL (SELECT csq_f FROM csq_f(csq_r.a));
 a 
---
 1
(1 row)

-- fails: correlation in distributed subplan
-- force_explain
explain SELECT * FROM csq_r WHERE a IN (SELECT csq_f FROM csq_f(csq_r.a),csq_r);
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=4)
   ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=4)
         Filter: CASE WHEN "ColRef_0022" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0022", 0::bigint) END > 0::bigint
         ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=500 width=16)
               ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=4)
               SubPlan 1
                 ->  Result  (cost=0.00..26.18 rows=1 width=8)
                       ->  Aggregate  (cost=0.00..25.16 rows=1 width=16)
                             ->  Result  (cost=0.00..24.11 rows=1 width=8)
                                   Filter: $0 = csq_f OR csq_f IS NULL
                                   ->  Materialize  (cost=0.00..23.10 rows=1 width=16)
                                         ->  Result  (cost=0.00..22.07 rows=1 width=16)
                                               ->  Nested Loop  (cost=0.00..21.04 rows=1 width=8)
                                                     Join Filter: true
                                                     ->  Materialize  (cost=0.00..2.03 rows=1 width=8)
                                                           ->  Result  (cost=0.00..1.02 rows=1 width=8)
                                                                 ->  Result  (cost=0.00..0.00 rows=1 width=1)
                                                     ->  Materialize  (cost=0.00..2.00 rows=1 width=1)
                                                           ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..1.00 rows=1 width=1)
                                                                 ->  Table Scan on csq_r  (cost=0.00..0.00 rows=1 width=1)
 Settings:  optimizer=on
(21 rows)

--
-- Test pullup of expr CSQs to joins
--
--
-- Test data
--
drop table if exists csq_pullup;
NOTICE:  table "csq_pullup" does not exist, skipping
create table csq_pullup(t text, n numeric, i int, v varchar(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into csq_pullup values ('abc',1, 2, 'xyz');
insert into csq_pullup values ('xyz',2, 3, 'def');  
insert into csq_pullup values ('def',3, 1, 'abc'); 
--
-- Expr CSQs to joins
--
--
-- text, text
--
explain select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.t=t1.t);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..5.17 rows=1 width=19)
   ->  Result  (cost=0.00..4.17 rows=1 width=19)
         Filter: 1 = CASE WHEN "ColRef_0023" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0023", 0::bigint) END
         ->  Result  (cost=0.00..3.15 rows=1 width=40)
               ->  Hash Left Join  (cost=0.00..2.11 rows=1 width=27)
                     Hash Cond: public.csq_pullup.t = public.csq_pullup.t
                     ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
                     ->  Hash  (cost=1.02..1.02 rows=1 width=12)
                           ->  HashAggregate  (cost=0.00..1.02 rows=1 width=12)
                                 Group By: public.csq_pullup.t
                                 ->  Table Scan on csq_pullup  (cost=0.00..0.00 rows=1 width=4)
 Settings:  optimizer=on
(12 rows)

select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.t=t1.t);
  t  | n | i |  v  
-----+---+---+-----
 xyz | 2 | 3 | def
 def | 3 | 1 | abc
 abc | 1 | 2 | xyz
(3 rows)

--
-- text, varchar
--
explain select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.t=t1.v);
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=19)
   ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=19)
         Filter: 1 = CASE WHEN "ColRef_0023" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0023", 0::bigint) END
         ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=500 width=40)
               ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
               SubPlan 1
                 ->  Aggregate  (cost=0.00..4.03 rows=1 width=8)
                       ->  Result  (cost=0.00..3.01 rows=1 width=1)
                             Filter: $0 = public.csq_pullup.v::text
                             ->  Materialize  (cost=0.00..2.01 rows=1 width=4)
                                   ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..1.01 rows=1 width=4)
                                         ->  Table Scan on csq_pullup  (cost=0.00..0.00 rows=1 width=4)
 Settings:  optimizer=on
(13 rows)

select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.t=t1.v);
  t  | n | i |  v  
-----+---+---+-----
 xyz | 2 | 3 | def
 def | 3 | 1 | abc
 abc | 1 | 2 | xyz
(3 rows)

--
-- numeric, numeric
--
explain select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.n=t1.n);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=0.00..7.21 rows=1 width=19)
   ->  Result  (cost=0.00..6.20 rows=1 width=19)
         Filter: 1 = CASE WHEN "ColRef_0023" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0023", 0::bigint) END
         ->  Result  (cost=0.00..5.18 rows=1 width=40)
               ->  Hash Left Join  (cost=0.00..4.15 rows=1 width=27)
                     Hash Cond: public.csq_pullup.n = public.csq_pullup.n
                     ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=19)
                           Hash Key: public.csq_pullup.n
                           ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
                     ->  Hash  (cost=2.04..2.04 rows=1 width=15)
                           ->  HashAggregate  (cost=0.00..2.04 rows=1 width=15)
                                 Group By: public.csq_pullup.n
                                 ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.01 rows=1 width=7)
                                       Hash Key: public.csq_pullup.n
                                       ->  Table Scan on csq_pullup  (cost=0.00..0.00 rows=1 width=7)
 Settings:  optimizer=on
(16 rows)

select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.n=t1.n);
  t  | n | i |  v  
-----+---+---+-----
 xyz | 2 | 3 | def
 def | 3 | 1 | abc
 abc | 1 | 2 | xyz
(3 rows)

--
-- function(numeric), function(numeric)
--
explain select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.n + 1=t1.n + 1);
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=19)
   ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=19)
         Filter: 1 = CASE WHEN "ColRef_0023" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0023", 0::bigint) END
         ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=500 width=40)
               ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
               SubPlan 1
                 ->  Aggregate  (cost=0.00..4.04 rows=1 width=8)
                       ->  Result  (cost=0.00..3.02 rows=1 width=1)
                             Filter: ($0 + 1::numeric) = (public.csq_pullup.n + 1::numeric)
                             ->  Materialize  (cost=0.00..2.02 rows=1 width=7)
                                   ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..1.01 rows=1 width=7)
                                         ->  Table Scan on csq_pullup  (cost=0.00..0.00 rows=1 width=7)
 Settings:  optimizer=on
(13 rows)

select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.n + 1=t1.n + 1);
  t  | n | i |  v  
-----+---+---+-----
 abc | 1 | 2 | xyz
 xyz | 2 | 3 | def
 def | 3 | 1 | abc
(3 rows)

--
-- function(numeric), function(int)
--
explain select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.n + 1=t1.i + 1);
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=19)
   ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=1 width=19)
         Filter: 1 = CASE WHEN "ColRef_0023" = (-1)::bigint THEN NULL::bigint ELSE COALESCE("ColRef_0023", 0::bigint) END
         ->  Result  (cost=0.00..10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00 rows=500 width=40)
               ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
               SubPlan 1
                 ->  Aggregate  (cost=0.00..4.03 rows=1 width=8)
                       ->  Result  (cost=0.00..3.01 rows=1 width=1)
                             Filter: ($0 + 1::numeric) = "numeric"(public.csq_pullup.i + 1)
                             ->  Materialize  (cost=0.00..2.01 rows=1 width=4)
                                   ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..1.01 rows=1 width=4)
                                         ->  Table Scan on csq_pullup  (cost=0.00..0.00 rows=1 width=4)
 Settings:  optimizer=on
(13 rows)

select * from csq_pullup t0 where 1= (select count(*) from csq_pullup t1 where t0.n + 1=t1.i + 1);
  t  | n | i |  v  
-----+---+---+-----
 xyz | 2 | 3 | def
 def | 3 | 1 | abc
 abc | 1 | 2 | xyz
(3 rows)

--
-- NOT EXISTS CSQs to joins
--
--
-- text, text
--
explain select * from csq_pullup t0 where not exists (select 1 from csq_pullup t1 where t0.t=t1.t and t1.i = 1);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..4.07 rows=1 width=19)
   ->  Hash Left Anti Semi Join  (cost=0.00..3.06 rows=1 width=19)
         Hash Cond: public.csq_pullup.t = public.csq_pullup.t
         ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
         ->  Hash  (cost=2.01..2.01 rows=1 width=4)
               ->  Result  (cost=0.00..2.01 rows=1 width=4)
                     ->  Table Scan on csq_pullup  (cost=0.00..1.01 rows=1 width=4)
                           Filter: i = 1
 Settings:  optimizer=on
(9 rows)

select * from csq_pullup t0 where not exists (select 1 from csq_pullup t1 where t0.t=t1.t and t1.i = 1);
  t  | n | i |  v  
-----+---+---+-----
 xyz | 2 | 3 | def
 abc | 1 | 2 | xyz
(2 rows)

--
-- int, function(int)
--
explain select * from csq_pullup t0 where not exists (select 1 from csq_pullup t1 where t0.i=t1.i + 1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=0.00..4.09 rows=1 width=19)
   ->  Hash Left Anti Semi Join  (cost=0.00..3.08 rows=1 width=19)
         Hash Cond: public.csq_pullup.i = (public.csq_pullup.i + 1)
         ->  Table Scan on csq_pullup  (cost=0.00..0.01 rows=1 width=19)
         ->  Hash  (cost=2.01..2.01 rows=1 width=4)
               ->  Broadcast Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.01 rows=1 width=4)
                     ->  Result  (cost=0.00..1.01 rows=1 width=4)
                           ->  Result  (cost=0.00..1.01 rows=1 width=4)
                                 ->  Table Scan on csq_pullup  (cost=0.00..0.00 rows=1 width=4)
 Settings:  optimizer=on
(10 rows)

select * from csq_pullup t0 where not exists (select 1 from csq_pullup t1 where t0.i=t1.i + 1);
  t  | n | i |  v  
-----+---+---+-----
 def | 3 | 1 | abc
(1 row)

--
-- FINRA wrong results bug MPP-16477
--
drop table if exists finra_t1;
NOTICE:  table "finra_t1" does not exist, skipping
drop table if exists finra_t2;
NOTICE:  table "finra_t2" does not exist, skipping
create table finra_t1(x int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into finra_t1 values(1),(2);
create table finra_t2(y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'y' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into finra_t2 values(1),(2),(2);
analyze finra_t1;
analyze finra_t2;
explain select * from finra_t1 where x in (select y from finra_t2);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.08 rows=1 width=4)
   ->  Hash EXISTS Join  (cost=0.00..1.08 rows=1 width=4)
         Hash Cond: finra_t1.x = finra_t2.y
         ->  Table Scan on finra_t1  (cost=0.00..0.00 rows=1 width=4)
         ->  Hash  (cost=0.01..0.01 rows=2 width=4)
               ->  Table Scan on finra_t2  (cost=0.00..0.01 rows=2 width=4)
 Settings:  optimizer=on
(7 rows)

select * from finra_t1 where x in (select y from finra_t2);
 x 
---
 1
 2
(2 rows)

-- start_ignore
-- Known_opt_diff: MPP-21351
-- end_ignore
explain select * from finra_t1 where x in (select y from finra_t2 union all select y from finra_t2);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..3.17 rows=1 width=4)
   ->  Hash EXISTS Join  (cost=0.00..2.16 rows=1 width=4)
         Hash Cond: finra_t1.x = "inner".y
         ->  Table Scan on finra_t1  (cost=0.00..0.00 rows=1 width=4)
         ->  Hash  (cost=1.04..1.04 rows=3 width=4)
               ->  Append  (cost=0.00..1.04 rows=3 width=4)
                     ->  Table Scan on finra_t2  (cost=0.00..0.01 rows=2 width=4)
                     ->  Table Scan on finra_t2  (cost=0.00..0.01 rows=2 width=4)
 Settings:  optimizer=on
(9 rows)

select * from finra_t1 where x in (select y from finra_t2 union all select y from finra_t2);
 x 
---
 1
 2
(2 rows)

explain select count(*) from finra_t1 where x in (select y from finra_t2);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate  (cost=0.00..3.10 rows=1 width=8)
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.08 rows=1 width=1)
         ->  Hash EXISTS Join  (cost=0.00..1.08 rows=1 width=1)
               Hash Cond: finra_t1.x = finra_t2.y
               ->  Table Scan on finra_t1  (cost=0.00..0.00 rows=1 width=4)
               ->  Hash  (cost=0.01..0.01 rows=2 width=4)
                     ->  Table Scan on finra_t2  (cost=0.00..0.01 rows=2 width=4)
 Settings:  optimizer=on
(8 rows)

select count(*) from finra_t1 where x in (select y from finra_t2);
 count 
-------
     2
(1 row)

-- start_ignore
-- Known_opt_diff: MPP-21351
-- end_ignore
explain select count(*) from finra_t1 where x in (select y from finra_t2 union all select y from finra_t2);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate  (cost=0.00..4.18 rows=1 width=8)
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..3.17 rows=1 width=1)
         ->  Hash EXISTS Join  (cost=0.00..2.16 rows=1 width=1)
               Hash Cond: finra_t1.x = "inner".y
               ->  Table Scan on finra_t1  (cost=0.00..0.00 rows=1 width=4)
               ->  Hash  (cost=1.04..1.04 rows=3 width=4)
                     ->  Append  (cost=0.00..1.04 rows=3 width=4)
                           ->  Table Scan on finra_t2  (cost=0.00..0.01 rows=2 width=4)
                           ->  Table Scan on finra_t2  (cost=0.00..0.01 rows=2 width=4)
 Settings:  optimizer=on
(10 rows)

select count(*) from finra_t1 where x in (select y from finra_t2 union all select y from finra_t2);
 count 
-------
     2
(1 row)

select count(*) from 
       ( select 1 as FIELD_1 union all select 2 as FIELD_1 ) TABLE_1 
       where FIELD_1 in ( select 1 as FIELD_1 union all select 1 as FIELD_1 union all select 1 as FIELD_1 );
 count 
-------
     1
(1 row)

       
---
--- Query was deadlocking because of not squelching subplans (MPP-18936)
---
drop table if exists t1; 
NOTICE:  table "t1" does not exist, skipping
drop table if exists t2; 
NOTICE:  table "t2" does not exist, skipping
drop table if exists t3; 
NOTICE:  table "t3" does not exist, skipping
drop table if exists t4; 
NOTICE:  table "t4" does not exist, skipping
CREATE TABLE t1 AS (SELECT generate_series(1, 5000) AS i, generate_series(5001, 10000) AS j);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t2 AS (SELECT * FROM t1 WHERE gp_segment_id = 0);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t3 AS (SELECT * FROM t1 WHERE gp_segment_id = 1);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t4 (i1 int, i2 int); 
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
set gp_interconnect_queue_depth=1;
-- This query was deadlocking on a 2P system
INSERT INTO t4 
(
SELECT t1.i, (SELECT t3.i FROM t3 WHERE t3.i + 1 = t1.i + 1)
FROM t1, t3
WHERE t1.i = t3.i
)
UNION
(
SELECT t1.i, (SELECT t2.i FROM t2 WHERE t2.i + 1 = t1.i + 1)
FROM t1, t2
WHERE t1.i = t2.i
);
drop table if exists t1; 
drop table if exists t2; 
drop table if exists t3; 
drop table if exists t4; 
